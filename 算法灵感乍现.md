# 集合类常考点

- 集合类里面要用包装类：Integer->int，Character->char

- Queue对应的是new LinkedList<>(); 函数：add，peek，remove

- 要考虑Queue是否为空

- Map对应的是new HashMap<>(); 函数：：put，get，remove(key)，containsKey，containsValue

- Map还有个好用的：map.getOrDefault(c, 0) 如果没有C的话就自动添加

  



# 原地维护有序数组(双指针)

![有序数组+双指针](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\有序数组+双指针-1735973413732.png)

**解析**：这个题要我们在**原数组里直接修改**，那么我们就只能用双指针。

用aim来表示最终结果数组的下标(可以看作一个新的nums，只不过是在原nums上进行操作)，value来表示最新的值，temp表示计数器

主要逻辑就是当计数器为2或者出现新的数时，就把i这个数拿到aim对应的位置上，并且aim++

(**反思**：这道题让我明白了，aim和value分开来的思想，value不是num[aim]，aim仅代表结果序列的下标，value代表最新值。作比较的是value，给结果赋值的是aim)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int aim=1, value=nums[0], temp=1;//temp为计数器,aim其实可以看做最终结果序列的下标
        for(int i=1; i<nums.length; i++){
            if(nums[i]!=value){
                temp=1;
                value = nums[i];
                nums[aim]=nums[i];
                aim++;
            }
            else {
                temp++;
                if(temp==2){
                    nums[aim]=nums[i];
                    aim++;
                }
            }
        }
        return aim;
    }
}
```





# 轮转数组(翻转法)

![轮转数组](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\轮转数组.png)<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\翻转数组.png" alt="翻转数组" style="zoom:50%;" />

我们发现每次往后移k mod n位，最后k mod n个数字都会到前面来，其余元素移动k mod n位。

我们其实可以看作是把数组进行了翻转，把后面的数字翻转到前面来，然后再针对局部进行翻转

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k%=nums.length;
        reverse(nums, 0, nums.length-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length-1);
    }

    public void reverse(int[] nums, int start, int end){
        while(start<end){
            int temp = nums[start];
            nums[start]=nums[end];
            nums[end]=temp;
            start+=1;
            end-=1;
        }
    }
}
```



# 跳跃游戏Ⅰ(贪心)

![跳跃游戏1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\跳跃游戏1.png)

处在i位时，最远可以跳到i+nums[i]位，也就是说在i~i+nums[i]位都可以到达，那么我们可以维护一个最远值maxn，只要maxn>=n-1则说明可以到达。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int n=nums.length;
        int maxn=0;
        for(int i=0; i<n; i++){
            if(i<=maxn){
            maxn = Math.max(maxn, i+nums[i]);
            if( maxn>=n-1) return true;
            }
        }
        return false;
    }
}
```





# 跳跃游戏Ⅱ(贪心)

![跳跃游戏2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\跳跃游戏2.png)

反向暴力查找也可，但是这里探讨正向

在Ⅰ的维护最大值基础上，我们需要引入一个边界end，只要我们到达边界，则step++，更新边界

ps:不必访问最后一个元素

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int end=0, maxn=0, step=0;
        for(int i=0; i<n-1; i++){
            maxn=Math.max(maxn, i+nums[i]);
            if(i==end){
                end=maxn;
                step++;
            }
        }
        return step;
    }
}
```





# H指数(二分/暴力)

![H指数](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\H指数.png)

反向遍历也可，这里主要探讨二分 

主要看二分的写法

```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int l=0, r=citations.length;
        while(l<r){
            int mid = (l+r+1)/2;
            int cnt=0;
            for(int i=0; i<citations.length; i++){
                if(citations[i]>=mid) cnt++;
            }

            if(cnt>=mid){
                l=mid;
            }else{
                r=mid-1;
            }
        }
        return l;
    }
}
```

 双模板(之前提到的)：至于l和r的边界，需要根据情况调整

​	(1) mid=l+r+1>>1;	if( check(mid) )	若true	l = mid；若false	r=mid-1;

​	(2) mid=l+r>>1;	if( check(mid) )	若true	r = mid；若false	l=mid+1;(对应关系)





# 时间插入删除随机(变长数组+哈希)

![时间插入删除随机](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\时间插入删除随机.png)

实际上更像是个模拟题

要实现O(1)的时间复杂度 -> 哈希，并且最后取随机 -> 变长数组

哈希里面，**val为key，对应的数组里的下标(长度)为value；**

```java
class RandomizedSet {
    List<Integer> nums;
    Map<Integer, Integer> res;
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<Integer>();
        res = new HashMap<Integer, Integer>();
        random = new Random();
    }
    
    public boolean insert(int val) {
        if(res.containsKey(val)) {
            return false;
        }
        int i = nums.size();
        nums.add(val);
        res.put(val, i);
        return true;
    }
    
    public boolean remove(int val) {
        if(!res.containsKey(val)){
            return false;
        }
        //当前位和最后一位交换
        int i = res.get(val);//由insert可知是i实际上是下标（也是当时对应的长度）
        int last = nums.get(nums.size()-1);
        nums.set(i, last);
        res.put(last, i);
        nums.remove(nums.size()-1);
        res.remove(val);
        return true;
    }
    
    public int getRandom() {
        int randomIndex = random.nextInt(nums.size());
        return nums.get(randomIndex);
    }
}
```





# 加油站(贪心+数学推导)

![加油站](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\加油站.png)

数学推导：

1.我们发现从x出发，最后可以到达y，那么可以得出：

![加油站推导1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\加油站推导1.png)

2.现在我们探讨，从[x, y]中任意一个z出发能否到达y+1的加油站：

![加油站推导2](D:\JAVA学习日志\typora\面试算法\所用截图\加油站推导2.png)

从这个式子中我们可以得出，z无论如何都无法到达y+1的加油站。

因此我们可以从0开始往后遍历，用cnt记录步数，能绕一圈则成功，不能则从第一个无法到达的点+1开始重新往后遍历，cnt也重置为0。

```java
class Solution {

    public int canCompleteCircuit(int[] gas, int[] cost) {
        //数学推导出一个性质：从x出发，最远能到y，那么从(x,y)中任意一个数z开始都无法到达y+1
        //所以我们从0开始走，走到第一个无法走的地方a就停下，从a+1开始
        int n = gas.length;
        int i=0;
        while(i<n){
            int sumOfGas=0, sumOfCost=0;//从当前位置开始加的gas和花费的cost的和
            int cnt=0;//步数
            while(cnt<n){
                int j=(i+cnt)%n;//%是用来>n-1时回到0
                sumOfGas+=gas[j];
                sumOfCost+=cost[j];
                if(sumOfGas<sumOfCost) break;//走不动了
                cnt++;
            }
            if(cnt==n) return i;
            else i+=cnt+1;
        }
        return -1;
    }
}
```



# 分发糖果

​	![分发糖果](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分发糖果-1735973521939.png)

我们从前往后遍历，如果rating[i]>rating[i-1]，则给i同学分配pre+1个糖果。

但是这里我们会发现，改变了后面的糖果数后，因为相邻两个孩子评分更高更多，所以还得反过去改前面，所以我们**需要维护一个递减数组dec和递增数组inc，因为结果只要数量，所以只需要dec和inc表示数量即可。**

如果rating[i]<rating[i-1]说明是递减要给dec数组里所有糖果数+1，因为dec表示递减数组数量，所以结果直接加dec即可。(PS：如果递减序列长度dec和递增序列长度inc一致，则需要把递增序列最后一个同学并入dec)

**我们其实也会发现，无论后面怎么变，也只会影响最近的递增数组的最大的一个**

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int ret=1;
        int inc = 1, dec = 0, pre=1;
        for(int i=1; i<n; i++){
            if(ratings[i]>=ratings[i-1]){//递增序列
                dec=0;
                pre = (ratings[i] == ratings[i-1] ? 1 :pre+1);//给当前同学分配pre+1
                ret+=pre;//并入结果
                inc = pre;//因为是+1递增，当前同学已经pre+1了，inc的长度也就是pre大小
            }else {
                dec++;
                if(dec==inc){//递增序列最后一个同学并入递减
                    dec++;
                }
                ret+=dec;
                pre=1;
            }
            System.out.println(dec+" "+inc+" "+pre);
        }
        return ret;
    }
}
```

官方图解：

![分糖果图解1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解1.png)

![分糖果图解2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解2.png)

![分糖果图解3](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解3.png)







# *两数之和O(n)重要双指针用法

**后续的双指针都可以按照这个思想延申**

![两数之和](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\两数之和.png)

直接backend=0, front=n-1然后大于目标front--，小于则backend++

会不会出现backend>=front的情况呢？因为数组的有序性，是不会出现这种情况的

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int front=numbers.length-1, backend=0;
        while(numbers[backend]+numbers[front]!=target){
            if(numbers[backend]+numbers[front]>target) {
                front--;
                continue;
            }
            if(numbers[backend]+numbers[front]<target) {
                backend++;
                continue;
            }
        }
        int[] res = new int[2];
        res[0]=backend+1;
        res[1]=front+1;
        return res;
    }
}
```



# Z字形变化(字符串索引)

![Z字形转换](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\Z字形转换.png)	

要求：将输入的字符串s，按照给定的numRows行数进行Z字行输出(其实更像N字形)。

PS：这里有个细节，结尾只要求我们输出字符串，而不是图形。也就是说只要保证每行里的字符没问题就行，不用考虑每行里字符应该是多少间距。

思路：遍历的同时模拟N字形，可以用二维数组下标，也可以用List<StringBuilder>。规律：每次遍历到0或者numRows-1的时候(也就是行的头尾)就要往反方向遍历了。

```java
class Solution {
    public String convert(String s, int numRows) {
        if(numRows<2) return s;
        List<StringBuilder> rows = new ArrayList<StringBuilder>();
        for(int i=0; i<numRows; i++) rows.add(new StringBuilder());
        
        int i=0, flag=-1;
        for(char c : s.toCharArray()){
            rows.get(i).append(c);
            if(i==0 || i==numRows-1) flag = -flag;//换方向
            i+=flag;
        }

        StringBuilder res = new StringBuilder();
        for(StringBuilder row:rows) res.append(row);
        return res.toString();
    }
}
```



# 找第一个字符串匹配的项(KMP)

![找字符串第一个匹配的项](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\找字符串第一个匹配的项.png)

题能暴力解，时间复杂度O(n*m)。主要学习KMP，时间复杂度O(n+m)。

主要分为两部分：构造next数组，匹配两个串

详细原理请见：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86

这个板子有个前提，给ss和pp串前面加了个" "**让他们下标从1开始**。

**第一部分：构造next数组** 

i从2开始，j从0开始

```java
// 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        int[] next = new int[m + 1];
        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i <= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j > 0 && p[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (p[i] == p[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }
```

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\KMP组成1.jpg" alt="KMP组成1" style="zoom:50%;" />	(中间是下标)

**第二部分：匹配**

i从1开始，j从0开始

```java
    // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
    for (int i = 1, j = 0; i <= n; i++) {
        // 匹配不成功 j = next(j)
        while (j > 0 && s[i] != p[j + 1]) j = next[j];
        // 匹配成功的话，先让 j++，结束本次循环后 i++
        if (s[i] == p[j + 1]) j++;
        // 整一段匹配成功，直接返回下标
        if (j == m) return i - m;
    }
```
![KMP组成2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\KMP组成2.jpg)	

完整代码：

这个板子很好记，因为是对称关系。只需要记next是i从2，j从0;匹配是i从1 j从0；然后for里面只有三步就OK

```java
class Solution {
    // KMP 算法
    // ss: 原串(string)  pp: 匹配串(pattern)
    public int strStr(String ss, String pp) {
        if (pp.isEmpty()) return 0;
        
        // 分别读取原串和匹配串的长度
        int n = ss.length(), m = pp.length();
        // 原串和匹配串前面都加空格，使其下标从 1 开始
        ss = " " + ss;
        pp = " " + pp;

        char[] s = ss.toCharArray();
        char[] p = pp.toCharArray();

        // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        int[] next = new int[m + 1];
        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i <= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j > 0 && p[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (p[i] == p[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }

        // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
        for (int i = 1, j = 0; i <= n; i++) {
            // 匹配不成功 j = next(j)
            while (j > 0 && s[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++，结束本次循环后 i++
            if (s[i] == p[j + 1]) j++;
            // 整一段匹配成功，直接返回下标
            if (j == m) return i - m;
        }

        return -1;
    }
}
```





# 三数之和

![三数之和](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\三数之和.png)

做法一(自己想的)：遍历第一个数，然后第二和第三个数用两数之和，引入set去重

```java
class Solution {
    Set<List<Integer>> res = new HashSet<>();
    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for(int i=0; i<n-2; i++){
            check(i, nums);
        }

        for(List<Integer> i : res){
            ans.add(i);
        }
        return ans;
    }

    public void check(int front, int[] nums){
        int n = nums.length;
        int i=front+1, j=n-1;
        if(i>=j) return;
        while(i<j){
            if(nums[front]+nums[i]+nums[j]==0) {
                List<Integer> ans = new ArrayList<>(Arrays.asList(nums[front],nums[i],nums[j]));
                if(!res.contains(ans)){
                    res.add(new ArrayList<>(Arrays.asList(nums[front],nums[i],nums[j])));
                }
                i++;
                j--;
                continue;
            }
            if(nums[front]+nums[i]+nums[j]>0) {
                j--;
                continue;
            }
            if(nums[front]+nums[i]+nums[j]<0) {
                i++;
                continue;
            }
        }
    }
}
```

方法二(标答)：另一种双指针

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for(int i=0; i<n; i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            check(i, nums);
        }
        return res;
    }

    public void check(int front, int[] nums){
        int n = nums.length;
        for(int i=front+1, j=n-1; i<n; i++){
            if(i>front+1 && nums[i]==nums[i-1]) continue;
            while(i<j && nums[front]+nums[i]+nums[j]>0) j--;
            if(i>=j) return;
            if(nums[front]+nums[i]+nums[j]==0) {
                List<Integer> ans = new ArrayList<>(Arrays.asList(nums[front],nums[i],nums[j]));
                // if(!res.contains(ans)){
                    res.add(new ArrayList<>(Arrays.asList(nums[front],nums[i],nums[j])));
                // }
            }
        }
    }
}
```



# 无重复字符的最长子串(队列+MAP)

子串是连续的，子序列是不连续的。

![](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\无重复字符的最长子串.png)	

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

思路：题目很简单，Queue当结果序列，Map打标记。

主要是有几个注意的点：

- 要考虑边界(本题)，就是while结束后是否还需要在进行一次while内的操作，以及for结束再进行一次max

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Queue<Character> queue = new LinkedList<>();
        Map<Character, Integer> map = new HashMap<>();
        int n = s.length();
        if(n==1) return 1;
        int maxn=0;
        for(int i = 0; i<n; i++){
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i), i);
                queue.add(s.charAt(i));
            }else {
                maxn=Math.max(maxn, queue.size());
                while(!queue.isEmpty()&&queue.peek()!=s.charAt(i)){
                    map.remove(queue.peek());
                    queue.remove();
                }
                if(!queue.isEmpty()) {
                    queue.remove();
                    map.remove(s.charAt(i));
                }
                map.put(s.charAt(i), i);
                queue.add(s.charAt(i));
            }
        }
        maxn=Math.max(maxn, queue.size());
        return maxn;

    }
}
```



# 有效的数独(哈希)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\有效的数独.png" alt="有效的数独" style="zoom:67%;" /><img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\示例.png" alt="示例" style="zoom: 50%;" />	

很简单的哈希的题:

行和列只需要维护两个哈希就行row[9] [index max = 9] line[9] [index max = 9]

小九宫格可以用一个三维数组box[3] [3] [index max = 9] //表示横3个竖3个九宫格每个九宫格里可以放9个数

易错点：读题读仔细，直接输入的是9x9大矩形，而不是一行表示一个小九宫格。

需要考虑的点：九宫格的下标如何确定，这里选择i/3和j/3

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] rows = new int[9][9];
        int[][] line = new int[9][9];
        int[][][] box = new int[3][3][9];

        for(int i=0; i<9; i++){
            for(int j=0; j<9; j++){
                char c = board[i][j];
                if(c!='.'){
                    int index = c-'0'-1;
                    rows[i][index]++;
                    line[j][index]++;
                    box[i/3][j/3][index]++;
                    if(rows[i][index]>1 || line[j][index]>1 || box[i/3][j/3][index]>1) return false;
                }
            }
        }
        return true;
    }
}
```





# 矩阵置零(原地+两个变量)

![矩阵置0](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\矩阵置0.png)

因为数据小可以用暴力，但是没意思，所以这里使用了原地+两个常量空间来解决。

**思路**：只要(x,y)==0,  **标记(0, y)=0,  (x,0)=0**。但是第0行和第0列就无法标记了，所以引入**两个变量来记录第0行和第0列**是否有0。

***注意**：最开始我想的是遍历第0行和第0列然后对分别置零行和列，但是会出现问题。所以最好的方法是**从(1,1)遍历非第0行和第0列的数组，然后判断(0, y)=0||(x,0)=0，成立则只对当前位置赋值0**。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        boolean row1 = false;
        boolean col1 = false;

        for(int i=0; i<row; i++){//0列
            if(matrix[i][0]==0) col1 = true;
        }
        for(int j=0; j<col; j++){//0行
            if(matrix[0][j]==0) row1 = true;
        }

        for(int i=1; i<row; i++){
            for(int j=1; j<col; j++){
                if(matrix[i][j]==0) matrix[i][0]=matrix[0][j]=0;
            }
        }

        for(int i=1; i<row; i++){
            for(int j=1; j<col; j++){
                if(matrix[i][0]==0 || matrix[0][j]==0){
                    matrix[i][j]=0;
                }
            }
        }

        if(row1==true) for(int i=0; i<col; i++) matrix[0][i]=0;
        if(col1==true) for(int j=0; j<row; j++) matrix[j][0]=0;
    }
}
```



更加进阶的做法：原地+1个常量空间

我们可以对方法二进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，**第一列的第一个元素即可以标记第一行是否出现 0**。但为了防止每一列的第一个元素被提前更新，我们需要**从最后一行开始，倒序地处理矩阵元素**。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean flagCol0 = false;
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                flagCol0 = true;
            }
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for (int i = m - 1; i >= 0; i--) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
            if (flagCol0) {
                matrix[i][0] = 0;
            }
        }
    }
}
```



# 生命游戏（通过状态来原地修改矩阵）

![image-20250104172209310](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250104172209310.png)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250104172220215.png" alt="image-20250104172220215" style="zoom:50%;" />	

非原地做法：多用一个表

```java
class Solution {
    int n=0;
    int m=0;
    int[] pox = {-1,  0, 1, -1, 1, -1, 0, 1};
    int[] poy = {-1, -1, -1, 0, 0, 1, 1, 1};


    public void gameOfLife(int[][] board) {
        n = board.length;
        m = board[0].length;
        int[][] temp = new int[n][m];

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                temp[i][j]=check(i, j, board);
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                board[i][j]=temp[i][j];
            }
        }
    }

    int check(int x, int y, int[][] board){
        int num1=0;//huo
        for(int i=0; i<8; i++){
                int X = x+pox[i];
                int Y = y+poy[i];
                if(X>=0 && X<n && Y>=0 && Y<m){
                    if(board[X][Y]==0) num0++;
                    else num1++;
                }
        }

        if(board[x][y]==0){
            if(num1==3) return 1;
            return 0;
        }else{
            if(num1>3 || num1<2) return 0;
            return 1;
        }
    }
}
```

原地修改:

利用特殊状态：-1表示过去活现在死，2表示现在死过去活，并且修改判断语句以及相应四个规则即可

```java
class Solution {
    //-1表示过去活现在死，2表示现在死过去活
    int n=0;
    int m=0;
    int[] pox = {-1,  0, 1, -1, 1, -1, 0, 1};
    int[] poy = {-1, -1, -1, 0, 0, 1, 1, 1};


    public void gameOfLife(int[][] board) {
        n = board.length;
        m = board[0].length;

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                check(i, j, board);
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(board[i][j]>0) board[i][j]=1;
                else board[i][j]=0;
            }
        }
    }

    void check(int x, int y, int[][] board){
        int num1=0;//huo
        for(int i=0; i<8; i++){
            int X = x+pox[i];
            int Y = y+poy[i];
            if(X>=0 && X<n && Y>=0 && Y<m){
                if(board[X][Y]==1 || board[X][Y]==-1) num1++;
            }
        }

        if(board[x][y]==0 && num1==3) board[x][y] = 2;
        if((board[x][y]==1) && (num1>3 || num1<2)) board[x][y] = -1;
    }
}
```









# 同构字符串（哈希）

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250107175615581.png" alt="image-20250107175615581" style="zoom: 67%;" />	

因为是一一对应关系，**我们只需要把key,value分别存对方就行**。一旦发现A的key对应的value不是当前B的值，则false

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        int n = s.length();
        char[] sa = s.toCharArray();
        char[] ta = t.toCharArray();

        Map<Character, Character> mapS = new HashMap<>();
        Map<Character, Character> mapT = new HashMap<>();

        for(int i=0; i<n; i++){
            char x = sa[i];
            char y = ta[i];
            if((mapS.containsKey(x)&&mapS.get(x)!=y)||(mapT.containsKey(y)&&mapT.get(y)!=x)) 
                return false;
            mapS.put(x, y);
            mapT.put(y, x);
        }
        return true;

    }
}
```

