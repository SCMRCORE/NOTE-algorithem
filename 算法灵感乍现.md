# 集合类常考点

- 集合类里面要用包装类：Integer->int，Character->char

- Queue对应的是new LinkedList<>(); 函数：add，peek，remove

- Deque对应的是new LinkedList<>(); 函数：addFirst，addLast，peekFirst，peekLast，removeFirts，removeLast，getFirts，getLast

- 要考虑Queue是否为空

- Map对应的是new HashMap<>(); 函数：：put，get，remove(key)，containsKey，containsValue

- Map还有个好用的：map.getOrDefault(c, 0) 如果没有C的话就自动添加；map.values()返回所有value，可见(字母异位词分组)

- 字符数组与字符串互转：char[] strArray = str.toCharArray();    
  **String key = Arrays.toString(strArray);或者String key = new String(strArray);**

- 字符串分割函数：String new = old.substring(start, end);
  
- dfs模板
  
<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204180222323.png" alt="image-20250204180222323" style="zoom:67%;" />	



# 原地维护有序数组(双指针)

![有序数组+双指针](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\有序数组+双指针-1735973413732.png)

**解析**：这个题要我们在**原数组里直接修改**，那么我们就只能用双指针。

用aim来表示最终结果数组的下标(可以看作一个新的nums，只不过是在原nums上进行操作)，value来表示最新的值，temp表示计数器

主要逻辑就是当计数器为2或者出现新的数时，就把i这个数拿到aim对应的位置上，并且aim++

(**反思**：这道题让我明白了，aim和value分开来的思想，value不是num[aim]，aim仅代表结果序列的下标，value代表最新值。作比较的是value，给结果赋值的是aim)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int aim=1, value=nums[0], temp=1;//temp为计数器,aim其实可以看做最终结果序列的下标
        for(int i=1; i<nums.length; i++){
            if(nums[i]!=value){
                temp=1;
                value = nums[i];
                nums[aim]=nums[i];
                aim++;
            }
            else {
                temp++;
                if(temp==2){
                    nums[aim]=nums[i];
                    aim++;
                }
            }
        }
        return aim;
    }
}
```





# 轮转数组(翻转法)

![轮转数组](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\轮转数组.png)<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\翻转数组.png" alt="翻转数组" style="zoom:50%;" />

我们发现每次往后移k mod n位，最后k mod n个数字都会到前面来，其余元素移动k mod n位。

我们其实可以看作是把数组进行了翻转，把后面的数字翻转到前面来，然后再针对局部进行翻转

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k%=nums.length;
        reverse(nums, 0, nums.length-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length-1);
    }

    public void reverse(int[] nums, int start, int end){
        while(start<end){
            int temp = nums[start];
            nums[start]=nums[end];
            nums[end]=temp;
            start+=1;
            end-=1;
        }
    }
}
```



# 跳跃游戏Ⅰ(贪心)

![跳跃游戏1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\跳跃游戏1.png)

处在i位时，最远可以跳到i+nums[i]位，也就是说在i~i+nums[i]位都可以到达，那么我们可以维护一个最远值maxn，只要maxn>=n-1则说明可以到达。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int n=nums.length;
        int maxn=0;
        for(int i=0; i<n; i++){
            if(i<=maxn){
            maxn = Math.max(maxn, i+nums[i]);
            if( maxn>=n-1) return true;
            }
        }
        return false;
    }
}
```





# 跳跃游戏Ⅱ(贪心)

![跳跃游戏2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\跳跃游戏2.png)

反向暴力查找也可，但是这里探讨正向

在Ⅰ的维护最大值基础上，我们需要引入一个边界end，只要我们到达边界，则step++，更新边界

ps:不必访问最后一个元素

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int end=0, maxn=0, step=0;
        for(int i=0; i<n-1; i++){
            maxn=Math.max(maxn, i+nums[i]);
            if(i==end){
                end=maxn;
                step++;
            }
        }
        return step;
    }
}
```





# H指数(二分/暴力)

![H指数](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\H指数.png)

反向遍历也可，这里主要探讨二分 

主要看二分的写法

```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int l=0, r=citations.length;
        while(l<r){
            int mid = (l+r+1)/2;
            int cnt=0;
            for(int i=0; i<citations.length; i++){
                if(citations[i]>=mid) cnt++;
            }

            if(cnt>=mid){
                l=mid;
            }else{
                r=mid-1;
            }
        }
        return l;
    }
}
```

 双模板(之前提到的)：至于l和r的边界，需要根据情况调整

​	(1) mid=l+r+1>>1;	if( check(mid) )	若true	l = mid；若false	r=mid-1;

​	(2) mid=l+r>>1;	if( check(mid) )	若true	r = mid；若false	l=mid+1;(对应关系)





# 时间插入删除随机(变长数组+哈希)

![时间插入删除随机](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\时间插入删除随机.png)

实际上更像是个模拟题

要实现O(1)的时间复杂度 -> 哈希，并且最后取随机 -> 变长数组

哈希里面，**val为key，对应的数组里的下标(长度)为value；**

```java
class RandomizedSet {
    List<Integer> nums;
    Map<Integer, Integer> res;
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<Integer>();
        res = new HashMap<Integer, Integer>();
        random = new Random();
    }
    
    public boolean insert(int val) {
        if(res.containsKey(val)) {
            return false;
        }
        int i = nums.size();
        nums.add(val);
        res.put(val, i);
        return true;
    }
    
    public boolean remove(int val) {
        if(!res.containsKey(val)){
            return false;
        }
        //当前位和最后一位交换
        int i = res.get(val);//由insert可知是i实际上是下标（也是当时对应的长度）
        int last = nums.get(nums.size()-1);
        nums.set(i, last);
        res.put(last, i);
        nums.remove(nums.size()-1);
        res.remove(val);
        return true;
    }
    
    public int getRandom() {
        int randomIndex = random.nextInt(nums.size());
        return nums.get(randomIndex);
    }
}
```





# 加油站(贪心+数学推导)

![加油站](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\加油站.png)

数学推导：

1.我们发现从x出发，最后可以到达y，那么可以得出：

![加油站推导1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\加油站推导1.png)

2.现在我们探讨，从[x, y]中任意一个z出发能否到达y+1的加油站：

![加油站推导2](D:\JAVA学习日志\typora\面试算法\所用截图\加油站推导2.png)

从这个式子中我们可以得出，z无论如何都无法到达y+1的加油站。

因此我们可以从0开始往后遍历，用cnt记录步数，能绕一圈则成功，不能则从第一个无法到达的点+1开始重新往后遍历，cnt也重置为0。

```java
class Solution {

    public int canCompleteCircuit(int[] gas, int[] cost) {
        //数学推导出一个性质：从x出发，最远能到y，那么从(x,y)中任意一个数z开始都无法到达y+1
        //所以我们从0开始走，走到第一个无法走的地方a就停下，从a+1开始
        int n = gas.length;
        int i=0;
        while(i<n){
            int sumOfGas=0, sumOfCost=0;//从当前位置开始加的gas和花费的cost的和
            int cnt=0;//步数
            while(cnt<n){
                int j=(i+cnt)%n;//%是用来>n-1时回到0
                sumOfGas+=gas[j];
                sumOfCost+=cost[j];
                if(sumOfGas<sumOfCost) break;//走不动了
                cnt++;
            }
            if(cnt==n) return i;
            else i+=cnt+1;
        }
        return -1;
    }
}
```



# 分发糖果

​	![分发糖果](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分发糖果-1735973521939.png)

我们从前往后遍历，如果rating[i]>rating[i-1]，则给i同学分配pre+1个糖果。

但是这里我们会发现，改变了后面的糖果数后，因为相邻两个孩子评分更高更多，所以还得反过去改前面，所以我们**需要维护一个递减数组dec和递增数组inc，因为结果只要数量，所以只需要dec和inc表示数量即可。**

如果rating[i]<rating[i-1]说明是递减要给dec数组里所有糖果数+1，因为dec表示递减数组数量，所以结果直接加dec即可。(PS：如果递减序列长度dec和递增序列长度inc一致，则需要把递增序列最后一个同学并入dec)

**我们其实也会发现，无论后面怎么变，也只会影响最近的递增数组的最大的一个**

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int ret=1;
        int inc = 1, dec = 0, pre=1;
        for(int i=1; i<n; i++){
            if(ratings[i]>=ratings[i-1]){//递增序列
                dec=0;
                pre = (ratings[i] == ratings[i-1] ? 1 :pre+1);//给当前同学分配pre+1
                ret+=pre;//并入结果
                inc = pre;//因为是+1递增，当前同学已经pre+1了，inc的长度也就是pre大小
            }else {
                dec++;
                if(dec==inc){//递增序列最后一个同学并入递减
                    dec++;
                }
                ret+=dec;
                pre=1;
            }
            System.out.println(dec+" "+inc+" "+pre);
        }
        return ret;
    }
}
```

官方图解：

![分糖果图解1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解1.png)

![分糖果图解2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解2.png)

![分糖果图解3](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解3.png)







# *两数之和O(n)重要双指针用法

**后续的双指针都可以按照这个思想延申**

![两数之和](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\两数之和.png)

直接backend=0, front=n-1然后大于目标front--，小于则backend++

会不会出现backend>=front的情况呢？因为数组的有序性，是不会出现这种情况的

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int front=numbers.length-1, backend=0;
        while(numbers[backend]+numbers[front]!=target){
            if(numbers[backend]+numbers[front]>target) {
                front--;
                continue;
            }
            if(numbers[backend]+numbers[front]<target) {
                backend++;
                continue;
            }
        }
        int[] res = new int[2];
        res[0]=backend+1;
        res[1]=front+1;
        return res;
    }
}
```



# Z字形变化(字符串索引)

![Z字形转换](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\Z字形转换.png)	

要求：将输入的字符串s，按照给定的numRows行数进行Z字行输出(其实更像N字形)。

PS：这里有个细节，结尾只要求我们输出字符串，而不是图形。也就是说只要保证每行里的字符没问题就行，不用考虑每行里字符应该是多少间距。

思路：遍历的同时模拟N字形，可以用二维数组下标，也可以用List<StringBuilder>。规律：每次遍历到0或者numRows-1的时候(也就是行的头尾)就要往反方向遍历了。

```java
class Solution {
    public String convert(String s, int numRows) {
        if(numRows<2) return s;
        List<StringBuilder> rows = new ArrayList<StringBuilder>();
        for(int i=0; i<numRows; i++) rows.add(new StringBuilder());
        
        int i=0, flag=-1;
        for(char c : s.toCharArray()){
            rows.get(i).append(c);
            if(i==0 || i==numRows-1) flag = -flag;//换方向
            i+=flag;
        }

        StringBuilder res = new StringBuilder();
        for(StringBuilder row:rows) res.append(row);
        return res.toString();
    }
}
```



# 找第一个字符串匹配的项(KMP)

![找字符串第一个匹配的项](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\找字符串第一个匹配的项.png)

题能暴力解，时间复杂度O(n*m)。主要学习KMP，时间复杂度O(n+m)。

主要分为两部分：构造next数组，匹配两个串

详细原理请见：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86

这个板子有个前提，给ss和pp串前面加了个" "**让他们下标从1开始**。

**第一部分：构造next数组** 

i从2开始，j从0开始

```java
// 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        int[] next = new int[m + 1];
        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i <= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j > 0 && p[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (p[i] == p[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }
```

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\KMP组成1.jpg" alt="KMP组成1" style="zoom:50%;" />	(中间是下标)

**第二部分：匹配**

i从1开始，j从0开始

```java
    // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
    for (int i = 1, j = 0; i <= n; i++) {
        // 匹配不成功 j = next(j)
        while (j > 0 && s[i] != p[j + 1]) j = next[j];
        // 匹配成功的话，先让 j++，结束本次循环后 i++
        if (s[i] == p[j + 1]) j++;
        // 整一段匹配成功，直接返回下标
        if (j == m) return i - m;
    }
```

![KMP组成2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\KMP组成2.jpg)	

完整代码：

这个板子很好记，因为是对称关系。只需要记next是i从2，j从0;匹配是i从1 j从0；然后for里面只有三步就OK

```java
class Solution {
    // KMP 算法
    // ss: 原串(string)  pp: 匹配串(pattern)
    public int strStr(String ss, String pp) {
        if (pp.isEmpty()) return 0;
        
        // 分别读取原串和匹配串的长度
        int n = ss.length(), m = pp.length();
        // 原串和匹配串前面都加空格，使其下标从 1 开始
        ss = " " + ss;
        pp = " " + pp;

        char[] s = ss.toCharArray();
        char[] p = pp.toCharArray();

        // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        int[] next = new int[m + 1];
        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i <= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j > 0 && p[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (p[i] == p[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }

        // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
        for (int i = 1, j = 0; i <= n; i++) {
            // 匹配不成功 j = next(j)
            while (j > 0 && s[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++，结束本次循环后 i++
            if (s[i] == p[j + 1]) j++;
            // 整一段匹配成功，直接返回下标
            if (j == m) return i - m;
        }

        return -1;
    }
}
```





# 三数之和

![三数之和](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\三数之和.png)

做法一(自己想的)：遍历第一个数，然后第二和第三个数用两数之和，引入set去重

```java
class Solution {
    Set<List<Integer>> res = new HashSet<>();
    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for(int i=0; i<n-2; i++){
            check(i, nums);
        }

        for(List<Integer> i : res){
            ans.add(i);
        }
        return ans;
    }

    public void check(int front, int[] nums){
        int n = nums.length;
        int i=front+1, j=n-1;
        if(i>=j) return;
        while(i<j){
            if(nums[front]+nums[i]+nums[j]==0) {
                List<Integer> temp = new ArrayList<>(Arrays.asList(nums[front],nums[i],nums[j]));
                res.add(temp);
                i++;
                j--;
                continue;
            }
            if(nums[front]+nums[i]+nums[j]>0) {
                j--;
                continue;
            }
            if(nums[front]+nums[i]+nums[j]<0) {
                i++;
                continue;
            }
        }
    }
}
```

方法二(标答)：另一种双指针

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for(int i=0; i<n; i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            check(i, nums);
        }
        return res;
    }

    public void check(int front, int[] nums){
        int n = nums.length;
        for(int i=front+1, j=n-1; i<n; i++){
            if(i>front+1 && nums[i]==nums[i-1]) continue;
            while(i<j && nums[front]+nums[i]+nums[j]>0) j--;
            if(i>=j) return;
            if(nums[front]+nums[i]+nums[j]==0) {
                List<Integer> ans = new ArrayList<>(Arrays.asList(nums[front],nums[i],nums[j]));
                res.add(ans);
            }
        }
    }
}
```



# 无重复字符的最长子串(队列+MAP)

子串是连续的，子序列是不连续的。

![](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\无重复字符的最长子串.png)	

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

思路：题目很简单，Queue当结果序列，Map打标记。

主要是有几个注意的点：

- 要考虑边界(本题)，就是while结束后是否还需要在进行一次while内的操作，以及for结束再进行一次max

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Queue<Character> queue = new LinkedList<>();
        Map<Character, Integer> map = new HashMap<>();
        int n = s.length();
        if(n==1) return 1;
        int maxn=0;
        for(int i = 0; i<n; i++){
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i), i);
                queue.add(s.charAt(i));
            }else {
                maxn=Math.max(maxn, queue.size());
                while(!queue.isEmpty()&&queue.peek()!=s.charAt(i)){
                    map.remove(queue.peek());
                    queue.remove();
                }
                if(!queue.isEmpty()) {
                    queue.remove();
                    map.remove(s.charAt(i));
                }
                map.put(s.charAt(i), i);
                queue.add(s.charAt(i));
            }
        }
        maxn=Math.max(maxn, queue.size());
        return maxn;

    }
}
```



# 有效的数独(哈希)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\有效的数独.png" alt="有效的数独" style="zoom:67%;" /><img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\示例.png" alt="示例" style="zoom: 50%;" />	

很简单的哈希的题:

行和列只需要维护两个哈希就行row[9] [index max = 9] line[9] [index max = 9]

小九宫格可以用一个三维数组box[3] [3] [index max = 9] //表示横3个竖3个九宫格每个九宫格里可以放9个数

易错点：读题读仔细，直接输入的是9x9大矩形，而不是一行表示一个小九宫格。

需要考虑的点：九宫格的下标如何确定，这里选择i/3和j/3

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] rows = new int[9][9];
        int[][] line = new int[9][9];
        int[][][] box = new int[3][3][9];

        for(int i=0; i<9; i++){
            for(int j=0; j<9; j++){
                char c = board[i][j];
                if(c!='.'){
                    int index = c-'0'-1;
                    rows[i][index]++;
                    line[j][index]++;
                    box[i/3][j/3][index]++;
                    if(rows[i][index]>1 || line[j][index]>1 || box[i/3][j/3][index]>1) return false;
                }
            }
        }
        return true;
    }
}
```





# 矩阵置零(原地+两个变量)

![矩阵置0](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\矩阵置0.png)

因为数据小可以用暴力，但是没意思，所以这里使用了原地+两个常量空间来解决。

**思路**：只要(x,y)==0,  **标记(0, y)=0,  (x,0)=0**。但是第0行和第0列就无法标记了，所以引入**两个变量来记录第0行和第0列**是否有0。

***注意**：最开始我想的是遍历第0行和第0列然后对分别置零行和列，但是会出现问题。所以最好的方法是**从(1,1)遍历非第0行和第0列的数组，然后判断(0, y)=0||(x,0)=0，成立则只对当前位置赋值0**。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        boolean row1 = false;
        boolean col1 = false;

        for(int i=0; i<row; i++){//0列
            if(matrix[i][0]==0) col1 = true;
        }
        for(int j=0; j<col; j++){//0行
            if(matrix[0][j]==0) row1 = true;
        }

        for(int i=1; i<row; i++){
            for(int j=1; j<col; j++){
                if(matrix[i][j]==0) matrix[i][0]=matrix[0][j]=0;
            }
        }

        for(int i=1; i<row; i++){
            for(int j=1; j<col; j++){
                if(matrix[i][0]==0 || matrix[0][j]==0){
                    matrix[i][j]=0;
                }
            }
        }

        if(row1==true) for(int i=0; i<col; i++) matrix[0][i]=0;
        if(col1==true) for(int j=0; j<row; j++) matrix[j][0]=0;
    }
}
```



更加进阶的做法：原地+1个常量空间

我们可以对方法二进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，**第一列的第一个元素即可以标记第一行是否出现 0**。但为了防止每一列的第一个元素被提前更新，我们需要**从最后一行开始，倒序地处理矩阵元素**。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean flagCol0 = false;
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                flagCol0 = true;
            }
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for (int i = m - 1; i >= 0; i--) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
            if (flagCol0) {
                matrix[i][0] = 0;
            }
        }
    }
}
```



# 生命游戏（通过状态来原地修改矩阵）

![image-20250104172209310](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250104172209310.png)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250104172220215.png" alt="image-20250104172220215" style="zoom:50%;" />	

非原地做法：多用一个表

```java
class Solution {
    int n=0;
    int m=0;
    int[] pox = {-1,  0, 1, -1, 1, -1, 0, 1};
    int[] poy = {-1, -1, -1, 0, 0, 1, 1, 1};


    public void gameOfLife(int[][] board) {
        n = board.length;
        m = board[0].length;
        int[][] temp = new int[n][m];

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                temp[i][j]=check(i, j, board);
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                board[i][j]=temp[i][j];
            }
        }
    }

    int check(int x, int y, int[][] board){
        int num1=0;//huo
        for(int i=0; i<8; i++){
                int X = x+pox[i];
                int Y = y+poy[i];
                if(X>=0 && X<n && Y>=0 && Y<m){
                    if(board[X][Y]==0) num0++;
                    else num1++;
                }
        }

        if(board[x][y]==0){
            if(num1==3) return 1;
            return 0;
        }else{
            if(num1>3 || num1<2) return 0;
            return 1;
        }
    }
}
```

原地修改:

利用特殊状态：-1表示过去活现在死，2表示现在死过去活，并且修改判断语句以及相应四个规则即可

```java
class Solution {
    //-1表示过去活现在死，2表示现在死过去活
    int n=0;
    int m=0;
    int[] pox = {-1,  0, 1, -1, 1, -1, 0, 1};
    int[] poy = {-1, -1, -1, 0, 0, 1, 1, 1};


    public void gameOfLife(int[][] board) {
        n = board.length;
        m = board[0].length;

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                check(i, j, board);
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(board[i][j]>0) board[i][j]=1;
                else board[i][j]=0;
            }
        }
    }

    void check(int x, int y, int[][] board){
        int num1=0;//huo
        for(int i=0; i<8; i++){
            int X = x+pox[i];
            int Y = y+poy[i];
            if(X>=0 && X<n && Y>=0 && Y<m){
                if(board[X][Y]==1 || board[X][Y]==-1) num1++;
            }
        }

        if(board[x][y]==0 && num1==3) board[x][y] = 2;
        if((board[x][y]==1) && (num1>3 || num1<2)) board[x][y] = -1;
    }
}
```









# 同构字符串（哈希存法）

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250107175615581.png" alt="image-20250107175615581" style="zoom: 67%;" />	

因为是一一对应关系，**我们只需要把key,value分别存对方就行**。一旦发现A的key对应的value不是当前B的值，则false

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        int n = s.length();
        char[] sa = s.toCharArray();
        char[] ta = t.toCharArray();

        Map<Character, Character> mapS = new HashMap<>();
        Map<Character, Character> mapT = new HashMap<>();

        for(int i=0; i<n; i++){
            char x = sa[i];
            char y = ta[i];
            if((mapS.containsKey(x)&&mapS.get(x)!=y)||(mapT.containsKey(y)&&mapT.get(y)!=x)) 
                return false;
            mapS.put(x, y);
            mapT.put(y, x);
        }
        return true;

    }
}
```





# 字母异位词分组(用Map函数进行优化)

![image-20250110223728147](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250110223728147.png)

这是原本的代码

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        List<String> keys = new ArrayList<>();
        int len = strs.length;
        for(String str :strs){
            char[] strArray = str.toCharArray();
            Arrays.sort(strArray);
            String key = Arrays.toString(strArray);
            if(!keys.contains(key)) keys.add(key);
            if(map.get(key)==null) {
                List<String> value = new ArrayList<>();
                value.add(str);
                map.put(key, value);
            }else{
                List<String> value = map.get(key);
                value.add(str);
                map.put(key, value);
            }
        }
        List<List<String>> res = new ArrayList<>();
        for(String key : keys){
            res.add(map.get(key));
        }
        return res;
    }
}
```

可以使用getOrDefault和map.values()来进行优化

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        int len = strs.length;
        for(String str :strs){
            char[] strArray = str.toCharArray();
            Arrays.sort(strArray);
            String key = Arrays.toString(strArray);
            List<String> value = map.getOrDefault(key, new ArrayList<String>());
            value.add(str);
            map.put(key, value);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```





# 快乐数字(数学+Map)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250119000646850.png" alt="image-20250119000646850" style="zoom: 67%;" />		

我们随便试几个数，会得出三种可能：1，循环，无限大

第一二种比较好验证，主要是第三种，我们可以试着把每一位为9时，即最大值对应的next求出来：

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250119000823303.png" alt="image-20250119000823303" style="zoom:50%;" />	

从这里可以看出，三位数999的next为243，也就是说三位数，要么为1，要么在243内的某个数循环，包括后面4位数，最大为324，在999范围内，13位数，最大为4位数，四位数就会退化为3位数......这么下来就可以知道不会存在无限大

这样的就简单了，我们直接暴力拆解每个数，用map记录，如果重复就return false

```java
class Solution {
    public boolean isHappy(int n) {
        Map<Integer, Integer> map = new HashMap<>();
        while(n!=1 && !map.containsKey(n)){
            map.put(n, 1);
            n = calcutale(n);
        }
        return n==1;
    }

    public int calcutale(int n){
        int res=0;
        while(n!=0){
            res+=(n%10)*(n%10);
            n/=10;
        }
        return res;
    }
}
```







# 合并区间(左边界升序+并集)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250125232842404.png" alt="image-20250125232842404" style="zoom: 67%;" />	

**思考点：当前R<目标L，说明无法合并，其余的可合并**

主要是处理边界，根据左边界**升序**，那么在**结果队列里最后一个元素也是L，R最大**的，可以直接拿去和剩余值比较。

- 如果结果队列R<当前区间L，说明无法合并，可以直接放入
- 否则说明可以合并，并且直接取双方R的最大值就行。

(PS：我们根据L来升序的，所以可以不考虑L直接取R最大值)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0) return new int[0][2];
        Arrays.sort(intervals, new Comparator<int[]>(){
            public int compare(int[] interval1, int[] interval2){
                return interval1[0] - interval2[0];
            }
        });
        List<int[]> merged = new ArrayList<int[]>();
        for(int i=0; i<intervals.length; i++){
            int L = intervals[i][0], R = intervals[i][1];
            if(merged.size()==0 || merged.get(merged.size()-1)[1]<L){
                merged.add(new int[]{L, R});
            }else{
                merged.get(merged.size()-1)[1] = 
                Math.max(merged.get(merged.size()-1)[1], R);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
}
```





# 插入区间(增强for+集合)

这个题给我的启发是，如果遇到**新的结果集合需要单独列指针的**，或许可以用**增强for来遍历筛选装入集合**，最后再装入结果集

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250128222736283.png" alt="image-20250128222736283" style="zoom: 67%;" />	

要点是打草稿，区分好几种情况：

**思考点：三种，左侧无交集，需要合并，右侧无交集**

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int left = newInterval[0];
        int right = newInterval[1];
        boolean placed = false;
        List<int[]> ansList = new ArrayList<int[]>();
        for(int[] interval : intervals){
            if(interval[0]>right){
                //右侧且无交集
                if(!placed) {
                    //遍历到右侧了，但还没添加新合并的区域
                    ansList.add(new int[]{left, right});
                    placed=true;
                }
                ansList.add(interval);
            }else if(interval[1]<left){
                //左侧且无交集
                ansList.add(interval);
            }else{
                //计算并集
                left=Math.min(left, interval[0]);
                right=Math.max(right, interval[1]);
            }
        }
        if(!placed){
            ansList.add(new int[]{left, right});
        }
        int[][] ans = new int[ansList.size()][2];
        for(int i=0; i<ansList.size(); i++){
            ans[i]=ansList.get(i);
        }
        return ans;
    }
}
```



# 最少的箭引爆气球(左边界升序+交集)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250201175716422.png" alt="image-20250201175716422" style="zoom:67%;" />	

**这个题两个范围有交集就可以被同时击破，所以可以先升序然后求交集**

**注意，自定义排序的时候，为了防止爆int，我们可以加两个if**

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        List<int[]> merge = new ArrayList<int[]>();
        Arrays.sort(points, new Comparator<int[]>(){
            public int compare(int[] left, int[] right){
                //防止爆int
                if(left[0]<0 && right[0]>0) return -1;
                if(left[0]>0 && right[0]<0) return 1;
                return left[0]-right[0];
            }
        });
        for(int[] point : points){
            int l = point[0], r = point[1];
            System.out.println(l+" "+r);
            if(merge.size()==0 || l>merge.get(merge.size()-1)[1]){
                merge.add(point);
            }else{
                merge.get(merge.size()-1)[0] = Math.max(l, merge.get(merge.size()-1)[0]);
                merge.get(merge.size()-1)[1] = Math.min(r, merge.get(merge.size()-1)[1]);
            }
        }
        return merge.size();
    }
}
```



# 有效括号(Deque)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250201184201844.png" alt="image-20250201184201844" style="zoom:67%;" />	

入门Deque题，Java推荐用Deque而不是stack

**坑点：左括号必须以正确顺序闭合，比如: `(])]` 这样就不行**

```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> deque = new LinkedList<>();
        char[] targets = s.toCharArray();
        for(char target : targets){
            if(target=='(' || target=='{' || target=='[')
                deque.addLast(target);
            else{
                if(deque.size()==0) return false;
                if(target==')'&& deque.getLast()!='(') return false;
                if(target=='}'&& deque.getLast()!='{') return false;
                if(target==']'&& deque.getLast()!='[') return false;
                deque.removeLast();
            }
        }
        return deque.isEmpty();
    }
}
```

PS:如果只是栈的操作的话，可以直接使用push和pop，这里为了练习双端队列

复习：

```powershell
add系列：失败抛异常
offer系列，不抛异常

remove系列：失败抛异常
poll系列，不抛异常

element/get系列：失败抛异常
peek系列，不抛异常
```





# 最长连续序列(Set)

![image-20250201190956773](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250201190956773.png)

坑点：不要求再原数组中连续，也就是说要**去重**

所以我们直接把他们都放入set，然后**只要当前num是某一序列开头，那么就开始while遍历**

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for(int num:nums) set.add(num);
        int maxn=0;
        for(int num:set){
            if(!set.contains(num-1)){//序列的开头
                int curNum = num;
                int len=1;
                while(set.contains(curNum+1)){
                    curNum++;
                    len++;
                }
                maxn=Math.max(maxn, len);
            }
        }
        return maxn;
    }
}
```





# *和为k的子数组(前缀和+哈希)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202182136704.png" alt="image-20250202182136704" style="zoom:67%;" />	

第一种做法：O(n^2)，遍历一遍，从当前i开始往前遍历求前缀和，遇到k，结果+1

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int res = 0;
        for(int i=0; i<n; i++){
            int pre = 0;
            for(int j=i; j>=0; j--){//从后往前遍历
                pre+=nums[j];
                if(pre==k) res++;
            }
        }
        return res;
    }
}
```

第二种做法：加上map(数, 次数)进行优化

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202182616654.png" alt="image-20250202182616654" style="zoom:50%;" />	推导过程，优化的第二个for

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int res = 0, pre=0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for(int i=0; i<n; i++){
            pre+=nums[i];
            if(map.containsKey(pre-k)){
                res+=map.get(pre-k);
            }
            map.put(pre, map.getOrDefault(pre, 0)+1);
        }
        return res;
    }
}
```





# 滑动窗口最大值(单调队列deque+降序)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202191101352.png" alt="image-20250202191101352" style="zoom:50%;" />	

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new LinkedList<>();
        int n = nums.length;
        for(int i=0; i<k; i++){
            //维护一个递减序列
            while(!deque.isEmpty() && nums[i]>=nums[deque.peekLast()]){
                deque.pollLast();
            }
            deque.offerLast(i);//存入的值是下标，这样也方便后续直接比较下标是否在范围内
        }

        int[] ans = new int[n-k+1];
        ans[0] = nums[deque.peekFirst()];
        for(int i=k; i<n; i++){
            while(!deque.isEmpty() && nums[i]>=nums[deque.peekLast()]){
                deque.pollLast();
            }
            deque.offerLast(i);
            //最大值下标比滑动窗口最左侧还小时，需要移除
            while(deque.peekFirst()<=i-k){
                deque.pollFirst();
            }
            ans[i-k+1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
```





# 最大子数组和(前缀和+前缀和极值)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202205954855.png" alt="image-20250202205954855" style="zoom: 50%;" />	

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] pre = new int[n];
        int maxn=-99999999;
        pre[0]=nums[0];
        for(int i=1; i<n; i++){
            pre[i]=pre[i-1]+nums[i];
        }
        int pre_min=0;
        for(int i=0; i<n; i++){
            maxn=Math.max(maxn, pre[i]-pre_min);//维护一个最小前缀和
            pre_min=Math.min(pre_min, pre[i]);
        }
        return maxn;
    }
}
```





# 缺失的第一个正数(手动置换)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202215610869.png" alt="image-20250202215610869" style="zoom:67%;" />	

因为要求O(n)所以没法用sort，但是我们可以**手动置换x到下标x-1的位置**，这样就方便我们直接查nums[i]!=i+1，只要不符合就是缺失

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i=0; i<n; i++){
            while(nums[i]>0 && nums[i]<=n && nums[nums[i]-1]!=nums[i]){
                //顺序不能变
                int temp = nums[nums[i]-1];
                nums[nums[i]-1]=nums[i];
                nums[i]=temp;
            }
        }
        for(int i=0; i<n; i++){
            if(nums[i]!=i+1){
                return i+1;
            }
        }
        return n+1;
    }
}
```



# 螺旋矩阵(用方向数组的思想)

![image-20250204164731812](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204164731812.png)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if(matrix==null||matrix.length==0||matrix[0].length==0)
            return res;
        int rows = matrix.length, columns = matrix[0].length;
        //标记数组
        boolean[][] visited = new boolean[rows][columns];
        int total = rows*columns;
        int row = 0, column = 0;
        //方向数组,参数
        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};//右，下，左，上，顺时针
        int directionIndex = 0;
        for(int i=0; i<total; i++){
            res.add(matrix[row][column]);
            visited[row][column]=true;
            int nextRow = row+directions[directionIndex][0];
            int nextColumn = column+directions[directionIndex][1];
            //到达边界
            if(nextRow<0||nextRow>=rows||nextColumn<0||nextColumn>=columns || visited[nextRow][nextColumn]==true){
                directionIndex = (directionIndex+1)%4;
            }
            row+=directions[directionIndex][0];
            column+=directions[directionIndex][1];
        }
        return res;
    }
}
```



# 搜索二维矩阵(每层二分)

![image-20250204171634214](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204171634214.png)

直接对每一层二分即可

**回忆：因为我们的条件是<=有等于，所以l=mid不用+1,同时mid要加1**

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n = matrix.length;
        int m = matrix[0].length;
        for(int i=0; i<n; i++){
            int l=0, r=m-1;
            while(l<r){
                int mid = l+r+1>>1;
                if(matrix[i][mid]<=target) l = mid;
                else r=mid-1; 
            }
            if(matrix[i][l]==target) return true;
        }
        return false;
    }
}
```







# 全排列/子集(dfs+集合类细节)

![image-20250204180025477](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204180025477.png)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        int n = nums.length;
        dfs(0, nums, n);
        return res;
    }

    public void dfs(int now, int[] nums, int n){
        if(now==n){
            res.add(new ArrayList<>(temp));//细节1，直接传temp的话是传引用，所以得new
            return;
        }

        for(int i=0; i<n; i++){
            if(temp.contains(nums[i])) continue;//拓展：可以像以前一样用visited数组，contains也行只是有时候要超时
            temp.add(nums[i]);
            dfs(now+1, nums, n);
            temp.remove(temp.size()-1);//细节2，remove函数参数是下标而不是值，这里可以用temp.size()-1
        }
    }
}
```

![image-20250204182238923](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204182238923.png)

在上面的基础上，分别按个数1，2，3来进行多次dfs即可

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    int len;
    public List<List<Integer>> subsets(int[] nums) {
        len = nums.length;
        res.add(new ArrayList<>());
        for(int i=1; i<=len; i++){
            dfs(0, nums ,i);
        }
        return res;
    }

    public void dfs(int now, int[]nums, int n){
        if(now==n){
            System.out.println(temp.toString());
            res.add(new ArrayList<>(temp));
            return;
        }

            for(int i=0; i<len; i++){
                if(temp.contains(nums[i])) return;
                temp.add(nums[i]);
                dfs(now+1, nums, n);
                temp.remove(temp.size()-1);
            }
    }
}
```



# 电话号码的字母组合(dfs+)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204200200014.png" alt="image-20250204200200014" style="zoom:67%;" />	

关键：**之前now一直当作计数器使用**，因为这里涉及到多个数字(多个组合)，所以可以**用now当作组合的序号**

```java
class Solution {
    List<String> res = new ArrayList<>();
    StringBuilder temp = new StringBuilder();
    
    public List<String> letterCombinations(String digits) {
        if(digits.length()==0) return new ArrayList<>();
        StringBuilder dictionary = new StringBuilder();
        Map<Character, String> map = new HashMap<>();
        map.put('2', "abc");//细节1：这种一对多的可以用map存储
        map.put('3', "def");
        map.put('4', "ghi");
        map.put('5', "jkl");
        map.put('6', "mno");
        map.put('7', "pqrs");
        map.put('8', "tuv");
        map.put('9', "wxyz");
        dfs(0, map, digits);
        return res;   
    }

    public void dfs(int now, Map<Character, String> map, String digits){
        if(now==digits.length()){
            System.out.println(temp);
            res.add(new String(temp.toString()));
            return;
        }

        char cur = digits.charAt(now);//关键
        char[] tagets = map.get(cur).toCharArray();
            for(int i=0; i<tagets.length; i++){
                temp.append(tagets[i]);
                dfs(now+1, map, digits);
                temp.deleteCharAt(temp.length()-1);//细节2：StringBuilder的函数
            }
    }
}
```

补充：为什么不需要visited数组

在解决全排列和电话号码字母组合问题时，是否需要使用`boolean`数组取决于**元素是否允许重复使用**以及**选择的约束条件**：

1. **全排列问题**
   - **每个元素必须使用且仅用一次**。例如，排列`[1,2,3]`时，每个数字在结果中必须出现一次。
   - 通过`boolean[]`标记哪些元素已被使用，避免重复选择。例如，在递归过程中，若已选择`1`，则后续层级不能再选`1`。
2. **电话号码字母组合问题**
   - **每个位置的选择是独立的**。例如，输入`"23"`时，第一个位置从`2`对应的字母（`a/b/c`）中选，第二个位置从`3`对应的字母（`d/e/f`）中选。不同位置的字母可以重复（如`"aa"`是允许的，前提是数字对应同一字母集合）。
   - 无需`boolean`数组，因为每次递归处理的是不同位置（不同数字），各步骤的选择互不影响。