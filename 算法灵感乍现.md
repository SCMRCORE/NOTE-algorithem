# 集合类常考点

- 集合类里面要用包装类：Integer->int，Character->char
- List集合，add，remove(下标)，常用remove(list.size()-1)来移除最后一位
- Collections有很多好用的对list的方法：

```java
Collections.max(list);
Collections.min(list);
Collections.sort(list);//升序
list.sort((o1, o2)->o1-o2);//也是升序
Collections.binarySearch(list, 100);//二分查找下标   
```

- Queue对应的是new LinkedList<>(); 函数：add/offer，peek/element，remove/poll
- Deque对应的是new LinkedList<>(); 函数：addFirst，addLast，peekFirst，peekLast，removeFirts，removeLast，getFirts，getLast
  PS：Deque<Integer> outStack=new ArrayDeque<>();是用数组实现的deque，一般在模拟题会用(栈模拟队列)
- 要考虑Queue是否为空
- Map对应的是new HashMap<>(); 函数：：put，get，remove(key)，containsKey，containsValue
- Map还有个好用的：map.getOrDefault(c, 0) 如果没有C的话就自动添加；map.values()返回所有value，可见(字母异位词分组)
- Set集合：add(值)，remove(值)
- 字符数组与字符串互转：char[] strArray = str.toCharArray();    
  **String key = Arrays.toString(strArray);或者String key = new String(strArray);**
- 字符串分割函数：String new = old.substring(start, end);
- StringBuilder对象，append，delete(start, end)，deleteCharAt()，toString()
- dfs模板
  

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204180222323.png" alt="image-20250204180222323" style="zoom:67%;" />	



# 原地维护有序数组(双指针)

![有序数组+双指针](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\有序数组+双指针-1735973413732.png)

**解析**：这个题要我们在**原数组里直接修改**，那么我们就只能用双指针。

用aim来表示最终结果数组的下标(可以看作一个新的nums，只不过是在原nums上进行操作)，value来表示最新的值，temp表示计数器

主要逻辑就是当计数器为2或者出现新的数时，就把i这个数拿到aim对应的位置上，并且aim++

(**反思**：这道题让我明白了，aim和value分开来的思想，value不是num[aim]，aim仅代表结果序列的下标，value代表最新值。作比较的是value，给结果赋值的是aim)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int aim=1, value=nums[0], temp=1;//temp为计数器,aim其实可以看做最终结果序列的下标
        for(int i=1; i<nums.length; i++){
            if(nums[i]!=value){
                temp=1;
                value = nums[i];
                nums[aim]=nums[i];
                aim++;
            }
            else {
                temp++;
                if(temp==2){
                    nums[aim]=nums[i];
                    aim++;
                }
            }
        }
        return aim;
    }
}
```





# 轮转数组(翻转法)

![轮转数组](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\轮转数组.png)<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\翻转数组.png" alt="翻转数组" style="zoom:50%;" />

我们发现每次往后移k mod n位，最后k mod n个数字都会到前面来，其余元素移动k mod n位。

我们其实可以看作是把数组进行了翻转，把后面的数字翻转到前面来，然后再针对局部进行翻转

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k%=nums.length;
        reverse(nums, 0, nums.length-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, nums.length-1);
    }

    public void reverse(int[] nums, int start, int end){
        while(start<end){
            int temp = nums[start];
            nums[start]=nums[end];
            nums[end]=temp;
            start+=1;
            end-=1;
        }
    }
}
```



# 跳跃游戏Ⅰ(贪心)

![跳跃游戏1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\跳跃游戏1.png)

处在i位时，最远可以跳到i+nums[i]位，也就是说在i~i+nums[i]位都可以到达，那么我们可以维护一个最远值maxn，只要maxn>=n-1则说明可以到达。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int n=nums.length;
        int maxn=0;
        for(int i=0; i<n; i++){
            if(i<=maxn){
            maxn = Math.max(maxn, i+nums[i]);
            if( maxn>=n-1) return true;
            }
        }
        return false;
    }
}
```





# 跳跃游戏Ⅱ(贪心)

![跳跃游戏2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\跳跃游戏2.png)

反向暴力查找也可，但是这里探讨正向

在Ⅰ的维护最大值基础上，我们需要引入一个边界end，只要我们到达边界，则step++，更新边界

ps:不必访问最后一个元素

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int end=0, maxn=0, step=0;
        for(int i=0; i<n-1; i++){
            maxn=Math.max(maxn, i+nums[i]);
            if(i==end){
                end=maxn;
                step++;
            }
        }
        return step;
    }
}
```





# H指数(二分/暴力)

![H指数](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\H指数.png)

反向遍历也可，这里主要探讨二分 

主要看二分的写法

```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int l=0, r=citations.length;
        while(l<r){
            int mid = (l+r+1)/2;
            int cnt=0;
            for(int i=0; i<citations.length; i++){
                if(citations[i]>=mid) cnt++;
            }

            if(cnt>=mid){
                l=mid;
            }else{
                r=mid-1;
            }
        }
        return l;
    }
}
```

 双模板(之前提到的)：至于l和r的边界，需要根据情况调整

​	(1) mid=l+r+1>>1;	if( check(mid) )	若true	l = mid；若false	r=mid-1;

​	(2) mid=l+r>>1;	if( check(mid) )	若true	r = mid；若false	l=mid+1;(对应关系)





# 时间插入删除随机(变长数组+哈希)

![时间插入删除随机](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\时间插入删除随机.png)

实际上更像是个模拟题

要实现O(1)的时间复杂度 -> 哈希，并且最后取随机 -> 变长数组

哈希里面，**val为key，对应的数组里的下标(长度)为value；**

```java
class RandomizedSet {
    List<Integer> nums;
    Map<Integer, Integer> res;
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<Integer>();
        res = new HashMap<Integer, Integer>();
        random = new Random();
    }
    
    public boolean insert(int val) {
        if(res.containsKey(val)) {
            return false;
        }
        int i = nums.size();
        nums.add(val);
        res.put(val, i);
        return true;
    }
    
    public boolean remove(int val) {
        if(!res.containsKey(val)){
            return false;
        }
        //当前位和最后一位交换
        int i = res.get(val);//由insert可知是i实际上是下标（也是当时对应的长度）
        int last = nums.get(nums.size()-1);
        nums.set(i, last);
        res.put(last, i);
        nums.remove(nums.size()-1);
        res.remove(val);
        return true;
    }
    
    public int getRandom() {
        int randomIndex = random.nextInt(nums.size());
        return nums.get(randomIndex);
    }
}
```





# 加油站(贪心+数学推导)

![加油站](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\加油站.png)

数学推导：

1.我们发现从x出发，最后可以到达y，那么可以得出：

![加油站推导1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\加油站推导1.png)

2.现在我们探讨，从[x, y]中任意一个z出发能否到达y+1的加油站：

![加油站推导2](D:\JAVA学习日志\typora\面试算法\所用截图\加油站推导2.png)

从这个式子中我们可以得出，z无论如何都无法到达y+1的加油站。

因此我们可以从0开始往后遍历，用cnt记录步数，能绕一圈则成功，不能则从第一个无法到达的点+1开始重新往后遍历，cnt也重置为0。

```java
class Solution {

    public int canCompleteCircuit(int[] gas, int[] cost) {
        //数学推导出一个性质：从x出发，最远能到y，那么从(x,y)中任意一个数z开始都无法到达y+1
        //所以我们从0开始走，走到第一个无法走的地方a就停下，从a+1开始
        int n = gas.length;
        int i=0;
        while(i<n){
            int sumOfGas=0, sumOfCost=0;//从当前位置开始加的gas和花费的cost的和
            int cnt=0;//步数
            while(cnt<n){
                int j=(i+cnt)%n;//%是用来>n-1时回到0
                sumOfGas+=gas[j];
                sumOfCost+=cost[j];
                if(sumOfGas<sumOfCost) break;//走不动了
                cnt++;
            }
            if(cnt==n) return i;
            else i+=cnt+1;
        }
        return -1;
    }
}
```



# 分发糖果

​	![分发糖果](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分发糖果-1735973521939.png)

我们从前往后遍历，如果rating[i]>rating[i-1]，则给i同学分配pre+1个糖果。

但是这里我们会发现，改变了后面的糖果数后，因为相邻两个孩子评分更高更多，所以还得反过去改前面，所以我们**需要维护一个递减数组dec和递增数组inc，因为结果只要数量，所以只需要dec和inc表示数量即可。**

如果rating[i]<rating[i-1]说明是递减要给dec数组里所有糖果数+1，因为dec表示递减数组数量，所以结果直接加dec即可。(PS：如果递减序列长度dec和递增序列长度inc一致，则需要把递增序列最后一个同学并入dec)

**我们其实也会发现，无论后面怎么变，也只会影响最近的递增数组的最大的一个**

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int ret=1;
        int inc = 1, dec = 0, pre=1;
        for(int i=1; i<n; i++){
            if(ratings[i]>=ratings[i-1]){//递增序列
                dec=0;
                pre = (ratings[i] == ratings[i-1] ? 1 :pre+1);//给当前同学分配pre+1
                ret+=pre;//并入结果
                inc = pre;//因为是+1递增，当前同学已经pre+1了，inc的长度也就是pre大小
            }else {
                dec++;
                if(dec==inc){//递增序列最后一个同学并入递减
                    dec++;
                }
                ret+=dec;
                pre=1;
            }
            System.out.println(dec+" "+inc+" "+pre);
        }
        return ret;
    }
}
```

官方图解：

![分糖果图解1](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解1.png)

![分糖果图解2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解2.png)

![分糖果图解3](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\分糖果图解3.png)







# *两数之和O(n)重要双指针用法

**后续的双指针都可以按照这个思想延申**

![两数之和](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\两数之和.png)

直接backend=0, front=n-1然后大于目标front--，小于则backend++

会不会出现backend>=front的情况呢？因为数组的有序性，是不会出现这种情况的

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int front=numbers.length-1, backend=0;
        while(numbers[backend]+numbers[front]!=target){
            if(numbers[backend]+numbers[front]>target) {
                front--;
                continue;
            }
            if(numbers[backend]+numbers[front]<target) {
                backend++;
                continue;
            }
        }
        int[] res = new int[2];
        res[0]=backend+1;
        res[1]=front+1;
        return res;
    }
}
```



# Z字形变化(字符串索引)

![Z字形转换](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\Z字形转换.png)	

要求：将输入的字符串s，按照给定的numRows行数进行Z字行输出(其实更像N字形)。

PS：这里有个细节，结尾只要求我们输出字符串，而不是图形。也就是说只要保证每行里的字符没问题就行，不用考虑每行里字符应该是多少间距。

思路：遍历的同时模拟N字形，可以用二维数组下标，也可以用List<StringBuilder>。规律：每次遍历到0或者numRows-1的时候(也就是行的头尾)就要往反方向遍历了。

```java
class Solution {
    public String convert(String s, int numRows) {
        if(numRows<2) return s;
        List<StringBuilder> rows = new ArrayList<StringBuilder>();
        for(int i=0; i<numRows; i++) rows.add(new StringBuilder());
        
        int i=0, flag=-1;
        for(char c : s.toCharArray()){
            rows.get(i).append(c);
            if(i==0 || i==numRows-1) flag = -flag;//换方向
            i+=flag;
        }

        StringBuilder res = new StringBuilder();
        for(StringBuilder row:rows) res.append(row);
        return res.toString();
    }
}
```



# 找第一个字符串匹配的项(KMP)

![找字符串第一个匹配的项](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\找字符串第一个匹配的项.png)

题能暴力解，时间复杂度O(n*m)。主要学习KMP，时间复杂度O(n+m)。

主要分为两部分：构造next数组，匹配两个串

详细原理请见：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86

这个板子有个前提，给ss和pp串前面加了个" "**让他们下标从1开始**。

**第一部分：构造next数组** 

i从2开始，j从0开始

```java
// 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        int[] next = new int[m + 1];
        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i <= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j > 0 && p[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (p[i] == p[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }
```

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\KMP组成1.jpg" alt="KMP组成1" style="zoom:50%;" />	(中间是下标)

**第二部分：匹配**

i从1开始，j从0开始

```java
    // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
    for (int i = 1, j = 0; i <= n; i++) {
        // 匹配不成功 j = next(j)
        while (j > 0 && s[i] != p[j + 1]) j = next[j];
        // 匹配成功的话，先让 j++，结束本次循环后 i++
        if (s[i] == p[j + 1]) j++;
        // 整一段匹配成功，直接返回下标
        if (j == m) return i - m;
    }
```

![KMP组成2](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\KMP组成2.jpg)	

完整代码：

这个板子很好记，因为是对称关系。只需要记next是i从2，j从0;匹配是i从1 j从0；然后for里面只有三步就OK

```java
class Solution {
    // KMP 算法
    // ss: 原串(string)  pp: 匹配串(pattern)
    public int strStr(String ss, String pp) {
        if (pp.isEmpty()) return 0;
        
        // 分别读取原串和匹配串的长度
        int n = ss.length(), m = pp.length();
        // 原串和匹配串前面都加空格，使其下标从 1 开始
        ss = " " + ss;
        pp = " " + pp;

        char[] s = ss.toCharArray();
        char[] p = pp.toCharArray();

        // 构建 next 数组，数组长度为匹配串的长度（next 数组是和匹配串相关的）
        int[] next = new int[m + 1];
        // 构造过程 i = 2，j = 0 开始，i 小于等于匹配串长度 【构造 i 从 2 开始】
        for (int i = 2, j = 0; i <= m; i++) {
            // 匹配不成功的话，j = next(j)
            while (j > 0 && p[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++
            if (p[i] == p[j + 1]) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;
        }

        // 匹配过程，i = 1，j = 0 开始，i 小于等于原串长度 【匹配 i 从 1 开始】
        for (int i = 1, j = 0; i <= n; i++) {
            // 匹配不成功 j = next(j)
            while (j > 0 && s[i] != p[j + 1]) j = next[j];
            // 匹配成功的话，先让 j++，结束本次循环后 i++
            if (s[i] == p[j + 1]) j++;
            // 整一段匹配成功，直接返回下标
            if (j == m) return i - m;
        }

        return -1;
    }
}
```





# 三数之和

![三数之和](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\三数之和.png)

做法一(自己想的)：遍历第一个数，然后第二和第三个数用两数之和，引入set去重

```java
class Solution {
    Set<List<Integer>> res = new HashSet<>();
    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for(int i=0; i<n-2; i++){
            check(i, nums);
        }

        for(List<Integer> i : res){
            ans.add(i);
        }
        return ans;
    }

    public void check(int front, int[] nums){
        int n = nums.length;
        int i=front+1, j=n-1;
        if(i>=j) return;
        while(i<j){
            if(nums[front]+nums[i]+nums[j]==0) {
                List<Integer> temp = new ArrayList<>(Arrays.asList(nums[front],nums[i],nums[j]));
                res.add(temp);
                i++;
                j--;
                continue;
            }
            if(nums[front]+nums[i]+nums[j]>0) {
                j--;
                continue;
            }
            if(nums[front]+nums[i]+nums[j]<0) {
                i++;
                continue;
            }
        }
    }
}
```

方法二(标答)：另一种双指针

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for(int i=0; i<n; i++){
            if(i>0 && nums[i]==nums[i-1]) continue;
            check(i, nums);
        }
        return res;
    }

    public void check(int front, int[] nums){
        int n = nums.length;
        for(int i=front+1, j=n-1; i<n; i++){
            if(i>front+1 && nums[i]==nums[i-1]) continue;
            while(i<j && nums[front]+nums[i]+nums[j]>0) j--;
            if(i>=j) return;
            if(nums[front]+nums[i]+nums[j]==0) {
                List<Integer> ans = new ArrayList<>(Arrays.asList(nums[front],nums[i],nums[j]));
                res.add(ans);
            }
        }
    }
}
```



# 无重复字符的最长子串(队列+MAP)

子串是连续的，子序列是不连续的。

![](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\无重复字符的最长子串.png)	

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

思路：题目很简单，Queue当结果序列，Map打标记。

主要是有几个注意的点：

- 要考虑边界(本题)，就是while结束后是否还需要在进行一次while内的操作，以及for结束再进行一次max

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Queue<Character> queue = new LinkedList<>();
        Map<Character, Integer> map = new HashMap<>();
        int n = s.length();
        if(n==1) return 1;
        int maxn=0;
        for(int i = 0; i<n; i++){
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i), i);
                queue.add(s.charAt(i));
            }else {
                maxn=Math.max(maxn, queue.size());
                while(!queue.isEmpty()&&queue.peek()!=s.charAt(i)){
                    map.remove(queue.peek());
                    queue.remove();
                }
                if(!queue.isEmpty()) {
                    queue.remove();
                    map.remove(s.charAt(i));
                }
                map.put(s.charAt(i), i);
                queue.add(s.charAt(i));
            }
        }
        maxn=Math.max(maxn, queue.size());
        return maxn;

    }
}
```



# 有效的数独(哈希)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\有效的数独.png" alt="有效的数独" style="zoom:67%;" /><img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\示例.png" alt="示例" style="zoom: 50%;" />	

很简单的哈希的题:

行和列只需要维护两个哈希就行row[9] [index max = 9] line[9] [index max = 9]

小九宫格可以用一个三维数组box[3] [3] [index max = 9] //表示横3个竖3个九宫格每个九宫格里可以放9个数

易错点：读题读仔细，直接输入的是9x9大矩形，而不是一行表示一个小九宫格。

需要考虑的点：九宫格的下标如何确定，这里选择i/3和j/3

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] rows = new int[9][9];
        int[][] line = new int[9][9];
        int[][][] box = new int[3][3][9];

        for(int i=0; i<9; i++){
            for(int j=0; j<9; j++){
                char c = board[i][j];
                if(c!='.'){
                    int index = c-'0'-1;
                    rows[i][index]++;
                    line[j][index]++;
                    box[i/3][j/3][index]++;
                    if(rows[i][index]>1 || line[j][index]>1 || box[i/3][j/3][index]>1) return false;
                }
            }
        }
        return true;
    }
}
```





# 矩阵置零(原地+两个变量)

![矩阵置0](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\矩阵置0.png)

因为数据小可以用暴力，但是没意思，所以这里使用了原地+两个常量空间来解决。

**思路**：只要(x,y)==0,  **标记(0, y)=0,  (x,0)=0**。但是第0行和第0列就无法标记了，所以引入**两个变量来记录第0行和第0列**是否有0。

***注意**：最开始我想的是遍历第0行和第0列然后对分别置零行和列，但是会出现问题。所以最好的方法是**从(1,1)遍历非第0行和第0列的数组，然后判断(0, y)=0||(x,0)=0，成立则只对当前位置赋值0**。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        boolean row1 = false;
        boolean col1 = false;

        for(int i=0; i<row; i++){//0列
            if(matrix[i][0]==0) col1 = true;
        }
        for(int j=0; j<col; j++){//0行
            if(matrix[0][j]==0) row1 = true;
        }

        for(int i=1; i<row; i++){
            for(int j=1; j<col; j++){
                if(matrix[i][j]==0) matrix[i][0]=matrix[0][j]=0;
            }
        }

        for(int i=1; i<row; i++){
            for(int j=1; j<col; j++){
                if(matrix[i][0]==0 || matrix[0][j]==0){
                    matrix[i][j]=0;
                }
            }
        }

        if(row1==true) for(int i=0; i<col; i++) matrix[0][i]=0;
        if(col1==true) for(int j=0; j<row; j++) matrix[j][0]=0;
    }
}
```



更加进阶的做法：原地+1个常量空间

我们可以对方法二进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，**第一列的第一个元素即可以标记第一行是否出现 0**。但为了防止每一列的第一个元素被提前更新，我们需要**从最后一行开始，倒序地处理矩阵元素**。

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean flagCol0 = false;
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                flagCol0 = true;
            }
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for (int i = m - 1; i >= 0; i--) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
            if (flagCol0) {
                matrix[i][0] = 0;
            }
        }
    }
}
```



# 生命游戏（通过状态来原地修改矩阵）

![image-20250104172209310](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250104172209310.png)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250104172220215.png" alt="image-20250104172220215" style="zoom:50%;" />	

非原地做法：多用一个表

```java
class Solution {
    int n=0;
    int m=0;
    int[] pox = {-1,  0, 1, -1, 1, -1, 0, 1};
    int[] poy = {-1, -1, -1, 0, 0, 1, 1, 1};


    public void gameOfLife(int[][] board) {
        n = board.length;
        m = board[0].length;
        int[][] temp = new int[n][m];

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                temp[i][j]=check(i, j, board);
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                board[i][j]=temp[i][j];
            }
        }
    }

    int check(int x, int y, int[][] board){
        int num1=0;//huo
        for(int i=0; i<8; i++){
                int X = x+pox[i];
                int Y = y+poy[i];
                if(X>=0 && X<n && Y>=0 && Y<m){
                    if(board[X][Y]==0) num0++;
                    else num1++;
                }
        }

        if(board[x][y]==0){
            if(num1==3) return 1;
            return 0;
        }else{
            if(num1>3 || num1<2) return 0;
            return 1;
        }
    }
}
```

原地修改:

利用特殊状态：-1表示过去活现在死，2表示现在死过去活，并且修改判断语句以及相应四个规则即可

```java
class Solution {
    //-1表示过去活现在死，2表示现在死过去活
    int n=0;
    int m=0;
    int[] pox = {-1,  0, 1, -1, 1, -1, 0, 1};
    int[] poy = {-1, -1, -1, 0, 0, 1, 1, 1};


    public void gameOfLife(int[][] board) {
        n = board.length;
        m = board[0].length;

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                check(i, j, board);
            }
        }

        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(board[i][j]>0) board[i][j]=1;
                else board[i][j]=0;
            }
        }
    }

    void check(int x, int y, int[][] board){
        int num1=0;//huo
        for(int i=0; i<8; i++){
            int X = x+pox[i];
            int Y = y+poy[i];
            if(X>=0 && X<n && Y>=0 && Y<m){
                if(board[X][Y]==1 || board[X][Y]==-1) num1++;
            }
        }

        if(board[x][y]==0 && num1==3) board[x][y] = 2;
        if((board[x][y]==1) && (num1>3 || num1<2)) board[x][y] = -1;
    }
}
```









# 同构字符串（哈希存法）

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250107175615581.png" alt="image-20250107175615581" style="zoom: 67%;" />	

因为是一一对应关系，**我们只需要把key,value分别存对方就行**。一旦发现A的key对应的value不是当前B的值，则false

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        int n = s.length();
        char[] sa = s.toCharArray();
        char[] ta = t.toCharArray();

        Map<Character, Character> mapS = new HashMap<>();
        Map<Character, Character> mapT = new HashMap<>();

        for(int i=0; i<n; i++){
            char x = sa[i];
            char y = ta[i];
            if((mapS.containsKey(x)&&mapS.get(x)!=y)||(mapT.containsKey(y)&&mapT.get(y)!=x)) 
                return false;
            mapS.put(x, y);
            mapT.put(y, x);
        }
        return true;

    }
}
```





# 字母异位词分组(用Map函数进行优化)

![image-20250110223728147](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250110223728147.png)

这是原本的代码

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        List<String> keys = new ArrayList<>();
        int len = strs.length;
        for(String str :strs){
            char[] strArray = str.toCharArray();
            Arrays.sort(strArray);
            String key = Arrays.toString(strArray);
            if(!keys.contains(key)) keys.add(key);
            if(map.get(key)==null) {
                List<String> value = new ArrayList<>();
                value.add(str);
                map.put(key, value);
            }else{
                List<String> value = map.get(key);
                value.add(str);
                map.put(key, value);
            }
        }
        List<List<String>> res = new ArrayList<>();
        for(String key : keys){
            res.add(map.get(key));
        }
        return res;
    }
}
```

可以使用getOrDefault和map.values()来进行优化

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        int len = strs.length;
        for(String str :strs){
            char[] strArray = str.toCharArray();
            Arrays.sort(strArray);
            String key = Arrays.toString(strArray);
            List<String> value = map.getOrDefault(key, new ArrayList<String>());
            value.add(str);
            map.put(key, value);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```





# 快乐数字(数学+Map)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250119000646850.png" alt="image-20250119000646850" style="zoom: 67%;" />		

我们随便试几个数，会得出三种可能：1，循环，无限大

第一二种比较好验证，主要是第三种，我们可以试着把每一位为9时，即最大值对应的next求出来：

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250119000823303.png" alt="image-20250119000823303" style="zoom:50%;" />	

从这里可以看出，三位数999的next为243，也就是说三位数，要么为1，要么在243内的某个数循环，包括后面4位数，最大为324，在999范围内，13位数，最大为4位数，四位数就会退化为3位数......这么下来就可以知道不会存在无限大

这样的就简单了，我们直接暴力拆解每个数，用map记录，如果重复就return false

```java
class Solution {
    public boolean isHappy(int n) {
        Map<Integer, Integer> map = new HashMap<>();
        while(n!=1 && !map.containsKey(n)){
            map.put(n, 1);
            n = calcutale(n);
        }
        return n==1;
    }

    public int calcutale(int n){
        int res=0;
        while(n!=0){
            res+=(n%10)*(n%10);
            n/=10;
        }
        return res;
    }
}
```







# 合并区间(左边界升序+并集)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250125232842404.png" alt="image-20250125232842404" style="zoom: 67%;" />	

**思考点：当前R<目标L，说明无法合并，其余的可合并**

主要是处理边界，根据左边界**升序**，那么在**结果队列里最后一个元素也是L，R最大**的，可以直接拿去和剩余值比较。

- 如果结果队列R<当前区间L，说明无法合并，可以直接放入
- 否则说明可以合并，并且直接取双方R的最大值就行。

(PS：我们根据L来升序的，所以可以不考虑L直接取R最大值)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0) return new int[0][2];
        Arrays.sort(intervals, new Comparator<int[]>(){
            public int compare(int[] interval1, int[] interval2){
                return interval1[0] - interval2[0];
            }
        });
        
        List<int[]> merged = new ArrayList<int[]>();
        for(int i=0; i<intervals.length; i++){
            int L = intervals[i][0], R = intervals[i][1];
            if(merged.size()==0 || merged.get(merged.size()-1)[1]<L){
                merged.add(new int[]{L, R});
            }else{
                merged.get(merged.size()-1)[1] = 
                Math.max(merged.get(merged.size()-1)[1], R);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
}
```





# 插入区间(增强for+集合)

这个题给我的启发是，如果遇到**新的结果集合需要单独列指针的**，或许可以用**增强for来遍历筛选装入集合**，最后再装入结果集

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250128222736283.png" alt="image-20250128222736283" style="zoom: 67%;" />	

要点是打草稿，区分好几种情况：

**思考点：三种，左侧无交集，需要合并，右侧无交集**

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int left = newInterval[0];
        int right = newInterval[1];
        boolean placed = false;
        List<int[]> ansList = new ArrayList<int[]>();
        for(int[] interval : intervals){
            if(interval[0]>right){
                //右侧且无交集
                if(!placed) {
                    //遍历到右侧了，但还没添加新合并的区域
                    ansList.add(new int[]{left, right});
                    placed=true;
                }
                ansList.add(interval);
            }else if(interval[1]<left){
                //左侧且无交集
                ansList.add(interval);
            }else{
                //计算并集
                left=Math.min(left, interval[0]);
                right=Math.max(right, interval[1]);
            }
        }
        if(!placed){
            ansList.add(new int[]{left, right});
        }
        int[][] ans = new int[ansList.size()][2];
        for(int i=0; i<ansList.size(); i++){
            ans[i]=ansList.get(i);
        }
        return ans;
    }
}
```



# 最少的箭引爆气球(左边界升序+交集)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250201175716422.png" alt="image-20250201175716422" style="zoom:67%;" />	

**这个题两个范围有交集就可以被同时击破，所以可以先升序然后求交集**

**注意，自定义排序的时候，为了防止爆int，我们可以加两个if**

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        List<int[]> merge = new ArrayList<int[]>();
        Arrays.sort(points, new Comparator<int[]>(){
            public int compare(int[] left, int[] right){
                //防止爆int
                if(left[0]<0 && right[0]>0) return -1;
                if(left[0]>0 && right[0]<0) return 1;
                return left[0]-right[0];
            }
        });
        for(int[] point : points){
            int l = point[0], r = point[1];
            System.out.println(l+" "+r);
            if(merge.size()==0 || l>merge.get(merge.size()-1)[1]){
                merge.add(point);
            }else{
                merge.get(merge.size()-1)[0] = Math.max(l, merge.get(merge.size()-1)[0]);
                merge.get(merge.size()-1)[1] = Math.min(r, merge.get(merge.size()-1)[1]);
            }
        }
        return merge.size();
    }
}
```



# 有效括号(Deque)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250201184201844.png" alt="image-20250201184201844" style="zoom:67%;" />	

入门Deque题，Java推荐用Deque而不是stack

**坑点：左括号必须以正确顺序闭合，比如: `(])]` 这样就不行**

```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> deque = new LinkedList<>();
        char[] targets = s.toCharArray();
        for(char target : targets){
            if(target=='(' || target=='{' || target=='[')
                deque.addLast(target);
            else{
                if(deque.size()==0) return false;
                if(target==')'&& deque.getLast()!='(') return false;
                if(target=='}'&& deque.getLast()!='{') return false;
                if(target==']'&& deque.getLast()!='[') return false;
                deque.removeLast();
            }
        }
        return deque.isEmpty();
    }
}
```

PS:如果只是栈的操作的话，可以直接使用push和pop，这里为了练习双端队列

复习：

```powershell
add系列：失败抛异常
offer系列，不抛异常

remove系列：失败抛异常
poll系列，不抛异常

element/get系列：失败抛异常
peek系列，不抛异常
```





# 最长连续序列(Set)

![image-20250201190956773](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250201190956773.png)

坑点：不要求再原数组中连续，也就是说要**去重**

所以我们直接把他们都放入set，然后**只要当前num是某一序列开头，那么就开始while遍历**

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for(int num:nums) set.add(num);
        int maxn=0;
        for(int num:set){
            if(!set.contains(num-1)){//序列的开头
                int curNum = num;
                int len=1;
                while(set.contains(curNum+1)){
                    curNum++;
                    len++;
                }
                maxn=Math.max(maxn, len);
            }
        }
        return maxn;
    }
}
```





# *和为k的子数组(前缀和+哈希)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202182136704.png" alt="image-20250202182136704" style="zoom:67%;" />	

第一种做法：O(n^2)，遍历一遍，从当前i开始往前遍历求前缀和，遇到k，结果+1

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int res = 0;
        for(int i=0; i<n; i++){
            int pre = 0;
            for(int j=i; j>=0; j--){//从后往前遍历
                pre+=nums[j];
                if(pre==k) res++;
            }
        }
        return res;
    }
}
```

第二种做法：加上map(数, 次数)进行优化

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202182616654.png" alt="image-20250202182616654" style="zoom:50%;" />	推导过程，优化的第二个for

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int res = 0, pre=0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for(int i=0; i<n; i++){
            pre+=nums[i];
            if(map.containsKey(pre-k)){
                res+=map.get(pre-k);
            }
            map.put(pre, map.getOrDefault(pre, 0)+1);
        }
        return res;
    }
}
```





# 滑动窗口最大值(单调队列deque+降序)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202191101352.png" alt="image-20250202191101352" style="zoom:50%;" />	

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new LinkedList<>();
        int n = nums.length;
        for(int i=0; i<k; i++){
            //维护一个递减序列
            while(!deque.isEmpty() && nums[i]>=nums[deque.peekLast()]){
                deque.pollLast();
            }
            deque.offerLast(i);//存入的值是下标，这样也方便后续直接比较下标是否在范围内
        }

        int[] ans = new int[n-k+1];
        ans[0] = nums[deque.peekFirst()];
        for(int i=k; i<n; i++){
            while(!deque.isEmpty() && nums[i]>=nums[deque.peekLast()]){
                deque.pollLast();
            }
            deque.offerLast(i);
            //最大值下标比滑动窗口最左侧还小时，需要移除
            while(deque.peekFirst()<=i-k){
                deque.pollFirst();
            }
            ans[i-k+1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
```





# 最大子数组和(前缀和+前缀和极值)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202205954855.png" alt="image-20250202205954855" style="zoom: 50%;" />	

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] pre = new int[n];
        int maxn=-99999999;
        pre[0]=nums[0];
        for(int i=1; i<n; i++){
            pre[i]=pre[i-1]+nums[i];
        }
        int pre_min=0;
        for(int i=0; i<n; i++){
            maxn=Math.max(maxn, pre[i]-pre_min);//维护一个最小前缀和
            pre_min=Math.min(pre_min, pre[i]);
        }
        return maxn;
    }
}
```





# 缺失的第一个正数(手动置换)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250202215610869.png" alt="image-20250202215610869" style="zoom:67%;" />	

因为要求O(n)所以没法用sort，但是我们可以**手动置换x到下标x-1的位置**，这样就方便我们直接查nums[i]!=i+1，只要不符合就是缺失

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i=0; i<n; i++){
            while(nums[i]>0 && nums[i]<=n && nums[nums[i]-1]!=nums[i]){
                //顺序不能变
                int temp = nums[nums[i]-1];
                nums[nums[i]-1]=nums[i];
                nums[i]=temp;
            }
        }
        for(int i=0; i<n; i++){
            if(nums[i]!=i+1){
                return i+1;
            }
        }
        return n+1;
    }
}
```



# 螺旋矩阵(用方向数组的思想)

![image-20250204164731812](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204164731812.png)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if(matrix==null||matrix.length==0||matrix[0].length==0)
            return res;
        int rows = matrix.length, columns = matrix[0].length;
        //标记数组
        boolean[][] visited = new boolean[rows][columns];
        int total = rows*columns;
        int row = 0, column = 0;
        //方向数组,参数
        int[][] directions = {{0,1},{1,0},{0,-1},{-1,0}};//右，下，左，上，顺时针
        int directionIndex = 0;
        for(int i=0; i<total; i++){
            res.add(matrix[row][column]);
            visited[row][column]=true;
            int nextRow = row+directions[directionIndex][0];
            int nextColumn = column+directions[directionIndex][1];
            //到达边界
            if(nextRow<0||nextRow>=rows||nextColumn<0||nextColumn>=columns || visited[nextRow][nextColumn]==true){
                directionIndex = (directionIndex+1)%4;
            }
            row+=directions[directionIndex][0];
            column+=directions[directionIndex][1];
        }
        return res;
    }
}
```



# 搜索二维矩阵(每层二分)

![image-20250204171634214](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204171634214.png)

直接对每一层二分即可

**回忆：因为我们的条件是<=有等于，所以l=mid不用+1,同时mid要加1**

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n = matrix.length;
        int m = matrix[0].length;
        for(int i=0; i<n; i++){
            int l=0, r=m-1;
            while(l<r){
                int mid = l+r+1>>1;
                if(matrix[i][mid]<=target) l = mid;
                else r=mid-1; 
            }
            if(matrix[i][l]==target) return true;
        }
        return false;
    }
}
```



# 用栈模拟队列

一个输入栈，一个输出栈，每当pop或者peek的时候把输入栈的全部压入输出栈，这样输出栈的顺序就是队列的顺序了，先进先出。

这里要用到数组实现的deque，用LinkedList就没意思了啊，本来就是要实现这个功能

```java
class MyQueue {
    Deque<Integer> inStack;
    Deque<Integer> outStack;


    public MyQueue() {
        inStack=new ArrayDeque<>();//数组实现的双端链表
        outStack=new ArrayDeque<>();
    }
    
    public void push(int x) {
        inStack.push(x);
    }
    
    public int pop() {
        if(outStack.isEmpty()){//检查输出栈是否为空
            pushInToOut();
        }
        return outStack.pop();
    }
    
    public int peek() {
        if(outStack.isEmpty()){//检查输出栈是否为空
            pushInToOut();
        }
        return outStack.peek();
    }
    
    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    public void pushInToOut(){//把输入栈的全部压入输出栈
        while(!inStack.isEmpty()){
            outStack.push(inStack.pop());
        }
    }
}
```





# 用队列模拟栈

没法像栈一样前后导，但是可以每次push后就前后交换顺序，就可以实现“先进后出”了，其他的就正常返回就行

```java
class MyStack {
    Queue<Integer> queue;

    public MyStack() {
        queue=new LinkedList<>();
    }
    
    public void push(int x) {
        int n = queue.size();
        queue.add(x);
        for(int i=0; i<n; i++){//这里的n是add之前的n
            queue.add(queue.poll());//每push一个，就前后置换位置
        }
    }
    
    public int pop() {
        return queue.remove();
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
```





# dfs合集





## 全排列/子集(dfs+集合类细节)

![image-20250204180025477](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204180025477.png)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        int n = nums.length;
        dfs(0, nums, n);
        return res;
    }

    public void dfs(int now, int[] nums, int n){
        if(now==n){
            res.add(new ArrayList<>(temp));//细节1，直接传temp的话是传引用，所以得new
            return;
        }

        for(int i=0; i<n; i++){
            if(temp.contains(nums[i])) continue;//拓展：可以像以前一样用visited数组，contains也行只是有时候要超时
            temp.add(nums[i]);
            dfs(now+1, nums, n);
            temp.remove(temp.size()-1);//细节2，remove函数参数是下标而不是值，这里可以用temp.size()-1
        }
    }
}
```

![image-20250204182238923](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204182238923.png)

在上面的基础上，分别按个数1，2，3来进行多次dfs即可

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    int len;
    public List<List<Integer>> subsets(int[] nums) {
        len = nums.length;
        res.add(new ArrayList<>());
        for(int i=1; i<=len; i++){
            dfs(0, nums ,i);
        }
        return res;
    }

    public void dfs(int now, int[]nums, int n){
        if(now==n){
            System.out.println(temp.toString());
            res.add(new ArrayList<>(temp));
            return;
        }

            for(int i=0; i<len; i++){
                if(temp.contains(nums[i])) return;
                temp.add(nums[i]);
                dfs(now+1, nums, n);
                temp.remove(temp.size()-1);
            }
    }
}
```



## 电话号码的字母组合(dfs+now)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250204200200014.png" alt="image-20250204200200014" style="zoom:67%;" />	

关键：**之前now一直当作计数器使用**，因为这里涉及到多个数字(多个组合)，所以可以**用now当作组合的序号**

```java
class Solution {
    List<String> res = new ArrayList<>();
    StringBuilder temp = new StringBuilder();
    
    public List<String> letterCombinations(String digits) {
        if(digits.length()==0) return new ArrayList<>();
        StringBuilder dictionary = new StringBuilder();
        Map<Character, String> map = new HashMap<>();
        map.put('2', "abc");//细节1：这种一对多的可以用map存储
        map.put('3', "def");
        map.put('4', "ghi");
        map.put('5', "jkl");
        map.put('6', "mno");
        map.put('7', "pqrs");
        map.put('8', "tuv");
        map.put('9', "wxyz");
        dfs(0, map, digits);
        return res;   
    }

    public void dfs(int now, Map<Character, String> map, String digits){
        if(now==digits.length()){
            System.out.println(temp);
            res.add(new String(temp.toString()));
            return;
        }

        char cur = digits.charAt(now);//关键
        char[] tagets = map.get(cur).toCharArray();//关键
            for(int i=0; i<tagets.length; i++){
                temp.append(tagets[i]);
                dfs(now+1, map, digits);
                temp.deleteCharAt(temp.length()-1);//细节2：StringBuilder的函数
            }
    }
}
```

补充：为什么不需要visited数组

在解决全排列和电话号码字母组合问题时，是否需要使用`boolean`数组取决于**元素是否允许重复使用**以及**选择的约束条件**：

1. **全排列问题**
   - **每个元素必须使用且仅用一次**。例如，排列`[1,2,3]`时，每个数字在结果中必须出现一次。
   - 通过`boolean[]`标记哪些元素已被使用，避免重复选择。例如，在递归过程中，若已选择`1`，则后续层级不能再选`1`。
2. **电话号码字母组合问题**
   - **每个位置的选择是独立的**。例如，输入`"23"`时，第一个位置从`2`对应的字母（`a/b/c`）中选，第二个位置从`3`对应的字母（`d/e/f`）中选。不同位置的字母可以重复（如`"aa"`是允许的，前提是数字对应同一字母集合）。
   - 无需`boolean`数组，因为每次递归处理的是不同位置（不同数字），各步骤的选择互不影响。







## 组合总和(dfs+重复选取+去重)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250205161741803.png" alt="image-20250205161741803" style="zoom:50%;" />	

我的做法：既然可以重复选取，那就不用visited[]数组，可以用now作为判断条件，然后结果先排序再装入set

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Set<List<Integer>> ans = new HashSet<>();
    List<Integer> temp = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(0, candidates, target);
        for(List<Integer> single : ans){
            res.add(single);
        }
        return res;
    }

    public void dfs(int now, int[] candidates, int target){
        if(now >= target){
            if(now==target){
                int[] unSorted =new int[temp.size()];
                for(int i=0; i<temp.size(); i++)
                    unSorted[i]=temp.get(i);
                Arrays.sort(unSorted); 
                List<Integer> sorted = new ArrayList<>();
                for(int i=0; i<temp.size(); i++)
                    sorted.add(unSorted[i]);
                ans.add(new ArrayList<>(sorted));
            }
            return;
        }

        for(int i=0; i<candidates.length; i++){
            temp.add(candidates[i]);
            dfs(now+candidates[i], candidates, target);
            temp.remove(temp.size()-1);
        }
    }
}
```





## 括号生成(dfs+判断去重)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250205173024334.png" alt="image-20250205173024334" style="zoom:67%;" />	

本层集合中元素就两个 ( 和 ) 所以也不需要visited数组

```java
class Solution {
    List<String> res = new ArrayList<>();
    Set<String> ans = new HashSet<>();
    StringBuilder stringbuilder = new StringBuilder();
    char[] targets = new char[20];

    public List<String> generateParenthesis(int n) {
        targets[0]='(';
        targets[1]=')';
        dfs(0, n);
        for(String s : ans) res.add(s);
        return res;
    }

    public void dfs(int now, int n){
        if(now==n*2){//3组括号，总长就是3*2
            if(check(stringbuilder)) ans.add(stringbuilder.toString());
            return;
        }

        for(int i=0; i<2; i++){
            stringbuilder.append(targets[i]);
            dfs(now+1, n);
            stringbuilder.deleteCharAt(stringbuilder.length()-1);
        }
    }

    public boolean check(StringBuilder stringbuilder){//检查合法
        Deque<Character> deque = new LinkedList<>();
        char[] checks = stringbuilder.toString().toCharArray();
        for(char c : checks){
            if(c=='(') deque.addLast('(');
            else{
                if(deque.size()==0) return false;
                deque.removeLast();
            }
        }
        if(deque.size()==0) return true;
        return false;
    }
}
```



## 单词搜索(二维)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250205192932723.png" alt="image-20250205192932723" style="zoom:50%;" />	

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250205192940527.png" alt="image-20250205192940527" style="zoom:50%;" />	`

虽然m和n最大为6，但是**对时间要求同样苛刻**，visited肯定要用，同时可以不用一个StringBuilder去存字符串合不合适，直接每进行一次dfs就对比当前`board[x+xnow][y+ynow]`是否等于word[now]就行，now既是步数也是下标，同样的也是基于这个特性，**只要now==word的长度**，便是找到了。

我在自己思考是想到了第一个减小耗时点，但是没想到第二个，第二个需要借助boolean类型的dfs才能实现

```java
class Solution {
    int[] rowNext = new int[]{0, 1, 0, -1};
    int[] colNext = new int[]{1, 0, -1, 0};
    boolean[][] visited = new boolean[7][7];

    public boolean exist(char[][] board, String word) {
        for(int i=0; i<board.length; i++){
            for(int j=0; j<board[0].length; j++){
                if(board[i][j]==word.charAt(0)){//第一个减小耗时点
                    visited[i][j]=true;
                    boolean flag = dfs(1, i, j, board, word);
                    visited[i][j]=false;
                    if(flag==true) return true;
                }
            }
        }
        return false;
    }

    public boolean dfs(int now, int x, int y, char[][] board, String word){
        if(now==word.length()) return true;

        boolean result = false;
        for(int i=0; i<4; i++){
            int xnow = x+rowNext[i];
            int ynow = y+colNext[i];
            if(xnow<0 || xnow>=board.length || ynow<0 || ynow>=board[0].length || visited[xnow][ynow]) continue;
            if(board[xnow][ynow]==word.charAt(now)){
                visited[xnow][ynow]=true;
                boolean flag = dfs(now+1, xnow, ynow, board, word);
                visited[xnow][ynow]=false;
                if(flag==true) {//第二个减小耗时点
                    result=true;
                    break;
                }
            }
        }
        return result;
    }
}
```





## 分隔回文串(dfs间距)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250205211135872.png" alt="image-20250205211135872" style="zoom:67%;" />	![image-20250205211850599](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250205211850599.png)

我的想法是直接**dfs分割间距**，now是当前所在的下标，详细看注解。右图是打印now和i时。

间隔坐标：0 a 1 a 2 b 3

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    List<String> ans = new ArrayList<>();
    boolean[] visited = new boolean[20];

    public List<List<String>> partition(String s) {
        int n = s.length();
        dfs(0, s);
        return res;
    }

    public void dfs(int now, String s){
        if(now==s.length()){
            if(check(ans)) res.add(new ArrayList<>(ans));
            return;
        }
        
		//从1开始到length可以看作是间隔，可以看图二
        //0 a 1 a 2 b 3
        for(int i=1; i<=s.length(); i++){
            if(now >= i || visited[i]) continue;//细节：now>=i，因为分割要保证连续，所以now必须得<i
            visited[i]=true;
            String temp;
            //判断是否到结尾3，到结尾直接切割从now到结尾就行
            if(i<s.length()){
                temp = s.substring(now, i);//start, end
            }else temp = s.substring(now);//now, end
            ans.add(temp);
            dfs(i, s);
            visited[i]=false;
            ans.remove(ans.size()-1);
        }
    }

    public boolean check(List<String> ans){//判断回文
        for(String single:ans){
            if(single.length()==1) continue;
            int start = 0, end =single.length()-1; 
            while(start<end){
                if(single.charAt(start)!=single.charAt(end))
                    return false;
                start++;
                end--;
            }
        }
        return true;
    }
}
```





# 链表合集

在Java里链表节点是这样的

![image-20250209182846278](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250209182846278.png)

## 相交链表

![image-20250209182918772](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250209182918772.png)

> 方法一：哈希法

直接存节点，遍历第二条时就检查是否包含

**易错点！！**：**必须要存节点而不是值，因为相交节点包含值和next值**

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
           Set<ListNode> set = new HashSet<>();
           ListNode temp = headA;
           while(temp.next!=null){
            set.add(temp);//存节点
            temp=temp.next;
           }
           temp=headB;
           while(temp.next!=null){
            if(set.contains(temp)){//检查节点
                return temp;
            }
            temp = temp.next;
           }
           return null;
    }
}
```

> 方法二：双指针

A遍历完读B，B遍历完读A

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null || headB==null) return null;
        ListNode pA = headA, pB = headB;
        while(pA!=pB){
            pA = pA==null ? headB : pA.next;
            pB = pB==null ? headA : pB.next;
        }
        return pA==pB?pA:null;
    }
}
```



## 反转链表(可递归)

![image-20250209195133422](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250209195133422.png)

方法1：

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode res = null;
        ListNode cur = head;
        while(cur!=null){
            ListNode temp = cur.next;//存下一个位置，和swap一样拿个中间节点
            cur.next = res;//当前节点指向新链表，类似于让后指向前
            res = cur;//更新为末端
            cur = temp;
        }
        return res;
    }
}
```

方法2：递归调用

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;//关键
        ListNode newhead = reverseList(head.next);//递归调用
        //让k+1指向k:head.next就是k+1,所以head.next就是(k+1).next，head就是k
        head.next.next = head;
        head.next  = null;
        return newhead;
    }
}
```

举例：1 2 3 4 5

head=4时：

newhead = reverseList(5) ，因为5.next=null，所以newhead = 5

head.next.next(5.next) = head(4)，head.next(4.next)=null;

此时newhead->5->4->null，return；

此时head便等于3**（补充：虽然4.next=null了但是3依然是指向4）**

head.next.next(4.next) = head(3)，head.next(3.next)=null;

此时newhead->5->4->3->null，return；

以此类推



## 回文链表

![image-20250209204536598](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250209204536598.png)

遍历一遍装入链表，然后前后双指针判断

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> list = new ArrayList<>();
        ListNode cur = head;
        while(cur!=null){
            list.add(cur.val);
            cur=cur.next;
        }
        int front=0, last=list.size()-1;
        while(front<last){
            if(list.get(front)!=list.get(last)) return false;
            front++;
            last--;
        }
        return true;
    }
}
```



## 环形链表

![image-20250209213716841](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250209213716841.png)

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
     Set<ListNode> set = new HashSet<>();
     ListNode cur = head;
     while(cur!=null){
        if(set.contains(cur.next)) return true;
        set.add(cur);
        cur=cur.next;
     }   
     return false;
    }
}
```

![image-20250209222516154](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250209222516154.png)

一样的

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set<ListNode> set = new HashSet<>();
        ListNode cur = head;
        while(cur!=null){
            if(set.contains(cur.next)) return cur.next;
            set.add(cur);
            cur=cur.next;
        }
        return null;
    }
}
```



## 合并两个有序链表(可递归)

![image-20250209224157577](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250209224157577.png)

方法1：递归：看注解

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1==null) return list2;
        else if(list2==null) return list1;
        else if(list1.val<list2.val) {
            //理解为l1排好了，拿l1.next和l2去比
            list1.next=mergeTwoLists(list1.next, list2);
            //开头时l1<l2，最终返回结果肯定开头是l1；中间比较时，l1结果小返回l1
            return list1;
        }else{
            list2.next=mergeTwoLists(list2.next, list1);
            return list2;//同理
        }
    }
}
```

方法2：正常比大小插入

ListNode prehead = new ListNode(-1);其实就是常说的哨兵节点，最终也是范围哨兵节点.next这样可以**避免处理头节点**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode prehead = new ListNode(-1);//留作开头
        ListNode pre = prehead;
        while(list1!=null && list2!=null){
            if(list1.val<=list2.val){
                pre.next=list1;
                list1=list1.next;
            }else{
                pre.next=list2;
                list2=list2.next;
            }
            pre=pre.next;
        }
        //合并后l1和l2最多只有一个未合并完
        pre.next = list1==null?list2:list1;
        return prehead.next;
    }
}
```

注意：这里的插入和反转链表插入是相反的



## 补充：头插和尾插

插头后成为头，插尾后成为尾

```java
//这两种插入法是一样的吗：
			//头插入：cur插入到res头部
            ListNode temp = cur.next;//和swap一样拿个中间节点
            cur.next = res;//当前节点指向新链表
            res = cur;//更新为末端
            cur = temp;
			//尾插入：res的next(尾)指向cur
            ListNode newNode = new ListNode(value); 
            res.next = newNode;
            res=res.next;
```





## 两数相加

![image-20250209233412196](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250209233412196.png)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode ans = new ListNode(-1);
        ListNode res = ans;
        int up = 0;
        while(l1!=null||l2!=null){
            int n1= l1!=null?l1.val:0;//当前val1
            int n2= l2!=null?l2.val:0;//当前val2
            int value = (n1+n2+up)%10;//新node值
            up = (n1+n2+up)/10;//要向下一位进多少

            ListNode newNode = new ListNode(value); 
            res.next = newNode;
            res=res.next;
            
            if(l1!=null)
                l1=l1.next;
            if(l2!=null)
                l2=l2.next;
        }
        if(up!=0) {//看是否还有要进一位的余数
            res.next = new ListNode(up);
        }
        return ans.next;
    }
}
```





## 删除链表的倒数第N个节点

![image-20250210001037907](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250210001037907.png)

最常规的遍历取长度，然后删除正数

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(n==0) return head;
        ListNode pre = head;
        int total = 0;
        while(pre!=null){
            total++;
            pre=pre.next;
        }
        if(total==1) return null;

        int target = total-n+1;//要删正数第几个
        ListNode prev = head;
        int num = 0;
        while(prev!=null){
            num++;
            if(num==target-1&&target==total)//结尾
                prev.next=null;
            if(target==1&&num==2) return prev; //开头
            if(num==target-1&&target!=total){
                prev.next=prev.next.next;
            }
            prev=prev.next;
        }
        return head;
    }
}
```

用List的写法，只遍历一次，既然我们遍历两次是为了获得长度，那么用集合类获取一样行

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        List<ListNode> list = new ArrayList<>();
        ListNode cur = head;

        while(cur!=null) {
            list.add(cur);
            cur=cur.next;
        }

        if(list.size()==1) return null;//只有一个
        if(list.size()-n==0) return list.get(1);//删开头

        ListNode temp = list.get(list.size()-n-1);
        if(temp.next==null) return head;//判断next是否null

        temp.next=temp.next.next;//删除要求节点
        return head;
    }
}
```





## 两两交换链表中的节点

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250210195112152.png" alt="image-20250210195112152" style="zoom:50%;" />	

草稿思路：

![image-20250210195120913](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250210195120913.png)	

题其实很简单，从草稿可以看出，**我们直接处理奇数位就行**，因为奇数位要处理的两个节点都在奇数位后。

除了**常规特判：空参和1个参外**，因为我们奇数位都是处理奇数位后的，所以要**特判下结尾**：**偶数结尾**，最后奇数位指向null，**奇数结尾**，倒数第二个奇数位(偶数结尾下的最后一个奇数位)指向最后奇数，比如123结果是213

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode cur = head;
        if(head==null || head.next==null) return head;
        ListNode res = head.next;
        while(cur.next!=null){
            if(cur.next.next==null){//处理常规偶数结尾
                cur.next.next=cur;
                cur.next=null;
                break;
            }
			//核心,直接着手奇数位
            ListNode temp = cur.next.next;//下一个奇数位
            cur.next.next = cur;//挨着的偶数位指向自己
            if(temp.next!=null)
                cur.next = temp.next;//指向下一个偶数位
            else 
                //特殊情况，奇数结尾，只有倒数第二个奇数才会处理这种情况，所以直接写在这里就行
                cur.next=temp;//指向最后一个奇数位

            cur = temp;
        }
        return res;
    }
}
```



## 随机链表复制(回溯)*

![image-20250210203135749](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250210203135749.png)

**难点和重点就在红框框，因为用常规拷贝法不好解决random问题，因为此时random并未创建，且random的需要的属性节点可能也未创建。**

我之前想到过用set来存，但是卡在了用什么作为内容，如果**用新节点的话，某些属性未赋值没法保证唯一性**，所以答案选择**用map且head的节点作为Key的很好的。**

然后就是回溯思想：**每次调用都只拷贝当前值**，至于next和random就直接调用方法进行

```java
class Solution {
    Map<Node, Node> map = new HashMap<>();
    //用head里完成的节点来当作Key,就能解决用新节点的某些熟悉还未赋值的问题
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        if(!map.containsKey(head)){
            //拷贝
            Node newNode = new Node(head.val);
            map.put(head, newNode);
            newNode.next=copyRandomList(head.next);
            newNode.random=copyRandomList(head.random);
        }
        return map.get(head);
    }
}
```



## 合并K个升序链表(暴力/优先队列)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250210221403687.png" alt="image-20250210221403687" style="zoom:67%;" />	

暴力写法，**直接两个两个合并**

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode cur = null;//这里不能是-1，因为不是插入节点，而是每次都覆盖
        for(int i=0; i<lists.length; i++){
            cur=mergeTwoLists(cur, lists[i]);
        }
        return cur;
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2){//合并两个节点
        if(l1==null || l2==null)
            return l1==null?l2:l1;

        ListNode ans = new ListNode(-1);
        ListNode cur = ans;
        while(l1!=null&&l2!=null){
            if(l1.val<=l2.val){
                cur.next=l1;
                l1=l1.next;
            }else{
                cur.next=l2;
                l2=l2.next;
            }
            cur=cur.next;
        }
        cur.next=(l1==null?l2:l1);
        return ans.next;
    }
}
```

暴力+递归(合并链表讲的)

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode cur = null;
        for(int i=0; i<lists.length; i++){
            cur=mergeTwoLists(cur, lists[i]);
        }
        return cur;
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2){
        if(l1==null || l2==null)
            return l1==null?l2:l1;
        if(l1.val<l2.val) {
            l1.next=mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next=mergeTwoLists(l2.next, l1);
            return l2;
        }
    }
}
```

**优先队列**：直接放进去

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
            (o1, o2)->{
            	return o1.val-o2.val;
            }
        );//自定义优先队列规则
        for(ListNode node : lists){
            if(node!=null) pq.offer(node);//全部放入
        }
        ListNode res=new ListNode(-1);
        ListNode cur =res;
        //优先规则其实相当于：每个链表的当前节点之间比较val，小的就拼接，然后next
        while(!pq.isEmpty()){
            ListNode nowNode = pq.poll();
            cur.next=nowNode;
            cur=cur.next;
            nowNode=nowNode.next;
            if(nowNode!=null) pq.offer(nowNode);
        }
        return res.next;
    }
}
```



## LRU(手写双向链表+hash)

![image-20250211153409244](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250211153409244.png)

记忆点：

- 链表结构
- 4个操作：添加头，移除，移动到头(依赖前两个，先移除再添加到头)，删除尾前(依赖移除)
- 4个属性：cache哈希，size，cache大小，伪头部伪尾部
- 三个主要操作：
  - LRUCache：初始化容量和缓存，初始化伪头部伪尾部设置引用
  - get：从cache哈希获取，判断存在，然后再移动到头部，返回值
  - put：从cache哈希获取，存在：更新value，移动到头部；不存在：创新节点，放哈希，添加到链表头部，size++，查看容量，多则移除size--

```java
class LRUCache {
    //定义链表
    class DLinkedNode{
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode(){}
        public DLinkedNode(int keynow, int valuenow){
            key=keynow;
            value=valuenow;
        }
    }

    private DLinkedNode head,tail;//伪头部和伪尾部
    private Map<Integer, DLinkedNode> cache = new HashMap<>();
    private int size;
    private int capacity;

    public LRUCache(int capacity) {
        //初始化初始容量和缓存大小
        this.size=0;
        this.capacity=capacity;
        //初始化伪头部和伪尾部,并互相设置引用
        head=new DLinkedNode();
        tail=new DLinkedNode();
        head.next=tail;
        tail.prev=head;
    }
    
    public int get(int key) {
        DLinkedNode node = cache.get(key);//从map获取
        if(node==null) return -1;
        moveToNode(node);//移到头部
        return node.value;
    }
    
    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if(node==null){//节点不存在
            //创建新链表
            DLinkedNode newNode = new DLinkedNode(key, value);
            //放入哈希表
            cache.put(key, newNode);
            //放入双向链表头部
            addToHead(newNode);
            //新增容量，检查是否超出容量
            size++;
            if(size>capacity){
                //先移除双向链表尾部，在移除哈希表
                DLinkedNode tail = removeTail();
                cache.remove(tail.key);
                size--;//减少容量
            }
        }else{//节点存在
            node.value=value;
            moveToNode(node);
        }
    }

    //添加头节点
    private void addToHead(DLinkedNode node){
        node.prev=head;//插入head后
        node.next=head.next;
        head.next.prev=node;//原本head后节点的前缀
        head.next=node;//原本head的后缀
    }
    //移除节点
    private void removeNode(DLinkedNode node){
        node.prev.next=node.next;//前缀的后缀
        node.next.prev=node.prev;//后缀的前缀
    }
    //移动到头节点
    private void moveToNode(DLinkedNode node){
        removeNode(node);
        addToHead(node);
    }
    //移除最后节点(尾巴节点前缀)，返回node是为cache哈希移除做准备
    private DLinkedNode removeTail(){
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```





## k个一组反转链表(快慢指针+递归)

![image-20250211160431340](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250211160431340.png)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        //先检查是否满足k个
        ListNode cur = head;
        int count=0;
        while(cur!=null) {
            count++;
            cur=cur.next;
        }
        if(count<k) return head;

        //快慢指针
        ListNode pre=head, nex=head.next;
        for(int i=0; i<k-1; i++){//k个节点反转k-1次
            ListNode temp = nex.next;//存下一个位置
            nex.next=pre;//反转，其实就是直接让右指向前，从左至右的过程，不需要管左边链表的next
            pre=nex;//去下两个节点
            nex=temp;
        }
        //修改开头，原头节点下一位应该指向下一组(比如1234,k=3，反转完3214，1指向4)，下一组开头就是现在的nex(4)
        head.next=reverseKGroup(nex, k);
        //pre反转完就是新的开头(3)
        return pre;
    }
}
```



## 排序链表(归并+合并)

![image-20250211162836144](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250211162836144.png)

方法1：时间nlogn，空间logn

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null)return head;
        ListNode slow=head;
        ListNode fast=head.next;
        //采用快慢指针，但是慢跳1格，快跳两格
        //结束时能保证slow的next是另一半开头
        while(fast!=null&&fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
        }
        ListNode head2=slow.next;//找到另一半的头节点
        slow.next=null;//断开链表
        return merge(sortList(head),sortList(head2));//归并两半
    }

    public ListNode merge(ListNode l1, ListNode l2){//递归合并有序链表
        if(l1==null || l2==null) 
            return l1==null?l2:l1;
        if(l1.val<=l2.val){
            l1.next=merge(l1.next, l2);
            return l1;
        }else{
            l2.next=merge(l1, l2.next);
            return l2;
        }
    }
}
```



## 排序链表(自底向上：待学)

```java
 public ListNode sortList(ListNode head) {
        if (head == null) return head;
        int len = 0;
        ListNode node = head;
        // 获取链表长度
        while (node != null) {
            ++len;
            node = node.next;
        }
        // 头结点存在被置换的可能，添加一个虚头结点，类似于哨兵
        ListNode front = new ListNode(0, head);
        // 开始对链表分段，一次分i段
        for (int i = 1; i < len; i <<= 1) {
            ListNode cur = front.next, pre = front;
            while (cur != null) {
                // h1为第一段
                ListNode h1 = cur;
                // 向后遍历到i的位置，即为第二段开始位置
                for (int j = 1; cur.next != null && j < i; ++j) {
                    cur = cur.next;
                }
                //h2为第二段
                ListNode h2 = cur.next;
                // 断开与第一段的连接
                cur.next = null;
                cur = h2;
                // 向后走与h1等同的长度
                for (int j = 1; cur != null && cur.next != null && j < i; ++j) {
                    cur = cur.next;
                }
                // 记录当前位置的指针，因为下一次要从这里开始分段
                ListNode next = null;
                if (cur != null) {
                    next = cur.next;
                    cur.next = null;
                }
                // 将前面的两段进行排序合并
                ListNode merge = merge(h1, h2);
                // 记录排序好的链表
                pre.next = merge;
                // 遍历到链表的尾部，方便连接下一次分段的排序后的链表
                while (pre.next != null) {
                    pre = pre.next;
                }
                // 回到刚才记录的位置，开始后面部分的分段与排序
                cur = next;
            }
            // i段分完后，开始进行i * 2段的分段排序，不难发现前面是两段进行排序结合，等于
            // 一个节点的两段 ： 1 * 2 = 2
            // 两个节点的两段 ： 2(上一轮已排好的) * 2(上一轮已排好的) = 4...以此类推
        }
        return front.next;
    }
    // 下面的排序过程就不解析了，很简单
    public ListNode merge(ListNode h1, ListNode h2) {
        ListNode front = new ListNode(0);
        ListNode mark = front, mark1 = h1, mark2 = h2;
        while (mark1 != null && mark2 != null) {
            if (mark1.val > mark2.val) {
                mark.next = mark2;
                mark2 = mark2.next;
            } else {
                mark.next = mark1;
                mark1 = mark1.next;
            }
            mark = mark.next;
        }
        if (mark1 != null) mark.next = mark1;
        else if (mark2 != null) mark.next = mark2;
        return front.next;
    }
```







# 二叉树合集

## 基础知识补充

```java
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
```

> **种类**

- 满二叉树：只有度为0和2的节点，也就是常说的排满
- 完全二叉树：每层填满后再去填下一层且从左到右
- 二叉搜索树：有序树，左<中<右
- 平衡二叉树：左右2子树高度差不超过1

> **存储方式**

链式存储和顺序存储

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213160659510.png" alt="image-20250213160659510" style="zoom: 50%;" />		<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213160734169.png" alt="image-20250213160734169" style="zoom:50%;" />	

用数组来存储二叉树如何遍历的呢？

**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

> **如何书写递归**

- **确定递归函数的参数和返回值**： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
- **确定终止条件**： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
- **确定单层递归的逻辑**： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



## 中序遍历

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213161100216.png" alt="image-20250213161100216" style="zoom:50%;" />	

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        tranversal(root, res);
        return res;
    }

    public void tranversal(TreeNode cur, List<Integer> res){
        if(cur==null) return;//终止条件
        tranversal(cur.left, res);//左
        res.add(cur.val);//中
        tranversal(cur.right, res);//右
    }
}
```

迭代法：维护stack

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stk = new LinkedList<>();
        while(root!=null || !stk.isEmpty()){
            while(root!=null){//读左
                stk.push(root);
                //stk.addLast(root);
                root=root.left;
            }
            root=stk.pop();//拿中
            //root=stk.removeLast();
            res.add(root.val);
            root=root.right;//看右
        }
        return res;
    }
}
```



## 二叉树最大深度

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213164535360.png" alt="image-20250213164535360" style="zoom:50%;" />	

```java
class Solution {
    int depthMax = 0;
    public int maxDepth(TreeNode root) {
        tranversal(root, 0);
        return depthMax;
    }

    public void tranversal(TreeNode root, int depth){
        if(root==null) {
            depthMax=Math.max(depthMax, depth);
            return;
        }
        tranversal(root.left, depth+1);
        tranversal(root.right, depth+1);
    }
}
```

这个其实和dfs几道题类似，**就是通过传参，然后终止时结算**



## 翻转二叉树

![image-20250213170010143](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213170010143.png)

翻转二叉树的要点其实就是**每个节点翻转自己的左右孩子节点**

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return root;
        //交换自己的左右节点
        TreeNode temp = root.left;
        root.left=root.right;
        root.right=temp;
        //交换左右子树
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```





## 对称二叉树

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213175205789.png" alt="image-20250213175205789" style="zoom:67%;" />	

关键：**左右同时遍历，左子树：左右中，右子树：右左中**

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return compare(root.left, root.right);
    }

    public boolean compare(TreeNode l, TreeNode r){
        //4种情况，只有l.val==r.val时才进行下面
        if(l!=null&&r==null) return false;
        if(l==null&&r!=null) return false;
        if(l==null&&r==null) return true;
        if(l.val!=r.val) return false;

        //左子树：左右中，右子树：右左中
        boolean check1 = compare(l.left, r.right);
        boolean check2 = compare(l.right, r.left);
        return check1 && check2;//判断对称结果
    }
}
```







## 二叉树直径*

![image-20250213182932507](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213182932507.png)

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213182940279.png" alt="image-20250213182940279" style="zoom:50%;" />	

**以经过节点数来算**

```java
class Solution {
    int diamMax;
    public int diameterOfBinaryTree(TreeNode root) {
        diamMax=1;//自己
        tranversal(root);
        return diamMax-1;//n个点,间隔就是n-1;
    }

    public int tranversal(TreeNode cur){
        if(cur==null) {
            return 0;
        }
        int L = tranversal(cur.left);//左节点向下最多经过L个
        int R = tranversal(cur.right);//右节点向下最多经过R个
        //以当前节点为根求最长经过节点：从当前节点触发最多经过L+R+1(自身)个
        diamMax = Math.max(diamMax, L+R+1)
        //以当前节点为儿子节点：本条线路最多max(L,R)+1(自身)
        return Math.max(L, R)+1;
    }
}
```

​	



## 层序遍历

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250213200957352.png" alt="image-20250213200957352" style="zoom:50%;" />	

递归法：正常递归，**然后节点所在层添加到对应list**

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return res;
        tranversal(root, 0);
        return res;
    }   

    public void tranversal(TreeNode cur, int deep){
        if(cur==null) return;
        List<Integer> temp;
        if(deep>=res.size()){
            temp = new ArrayList<>();
            res.add(deep, temp);//避免重复添加temp
        }
        temp=res.get(deep);    
        temp.add(cur.val);
        tranversal(cur.left, deep+1);
        tranversal(cur.right, deep+1);
    }
}
```

bfs法:广度遍历，看起来更像一层一层

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return res;
        tranversal(root);
        return res;
    }   

    public void tranversal(TreeNode cur){
        if(cur==null) return;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(cur);//别忘了把最初节点放进去

        while(!queue.isEmpty()){//bfs
            List<Integer> itemlist = new ArrayList<>();
            int len = queue.size();
            //还是通过层数来填充，每一层的节点都会在queue里，看起来是一层一层的
            while(len>0){
                TreeNode node = queue.poll();
                itemlist.add(node.val);//装入
                //子节点装入queue，填充下一层
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
                len--;
            }
            res.add(itemlist);
        }
    }
}
```





## 将有序数组转换为二叉搜索树*

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250214150350267.png" alt="image-20250214150350267" style="zoom:67%;" />	

**观察到给定数组就是中序遍历的，所以root点可以从中间取，然后分别递归左和右区域**

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length-1);
    }

    public TreeNode helper(int[] nums, int left, int right){
        if(left>right) return null;

        int mid = (left+right)/2;//选择中间位置左边节点(偶)

        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid-1);//左边区域
        root.right = helper(nums, mid+1, right);//右边区域
        return root;

    }
}
```





## 验证二叉搜索树*

![image-20250214154325408](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250214154325408.png)

我最开始的想法是查看每个节点和自己的left和right的关系就好了，结果太局限了，不能满足所有左子树<自己<右子树。

**所有咱们得维护一个范围**,左子树就（lower，cur.val）右子树就（cur.val, upper)

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isEfficent(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    
    public boolean isEfficent(TreeNode cur, long lower, long upper){
        if(cur==null) return true;
        if(cur.val<=lower||cur.val>=upper) return false;
        return isEfficent(cur.left, lower, cur.val) && isEfficent(cur.right,cur.val, upper);//分别递归左子树和右子树
    }

}
```



## 二叉搜索树中第K小的元素*

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250214160401530.png" alt="image-20250214160401530" style="zoom:50%;" />	

最暴力的做法，装进list然后sort

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public int kthSmallest(TreeNode root, int k) {
        findNode(root);
        list.sort((o1, o2)->o1-o2);
        // Collections.sort(list);
        return list.get(k-1);
    }

    public void findNode(TreeNode cur){
        if(cur==null) return ;
        list.add(cur.val);
        findNode(cur.left);
        findNode(cur.right);
    }
}
```

**中序遍历**（推荐）

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Deque<TreeNode> stack = new LinkedList<>();
        while(root!=null || !stack.isEmpty()){
            while(root!=null){//读左
                stack.push(root);
                root=root.left;
            }
            root=stack.pop();//拿中
            k--;
            if(k==0){
                break;
            }
            root=root.right;//看右
        }
        return root.val;
    }
}
```





## 二叉树的右视图*

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250214162536955.png" alt="image-20250214162536955" style="zoom:67%;" />	

**直接层序遍历，然后取每一层最后一个即可**

递归

```java
class Solution {
    List<Integer> res = new ArrayList<>();
    List<List<Integer>> nodes = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        tranversal(root, 0);
        for(List<Integer> node:nodes){
            res.add(node.get(node.size()-1));
        }
        return res;
    }

    public void tranversal(TreeNode cur, int deepth){
        if(cur==null) return;
        List<Integer> nowList;
        if(deepth>=nodes.size()){
            nowList=new ArrayList<>();
            nodes.add(deepth, nowList);
        }
        nowList=nodes.get(deepth);
        nowList.add(cur.val);
        tranversal(cur.left, deepth+1);
        tranversal(cur.right, deepth+1);
    }
}
```

bfs

```java
class Solution {
    List<Integer> res = new ArrayList<>();
    List<List<Integer>> nodes = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        tranversal(root);
        for(List<Integer> node:nodes){
            res.add(node.get(node.size()-1));
        }
        return res;
    }

    public void tranversal(TreeNode cur){
        if(cur==null) return;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(cur);

        while(!queue.isEmpty()){
            List<Integer> temp = new ArrayList<>();
            int len = queue.size();
            while(len>0){
                TreeNode node = queue.poll();
                temp.add(node.val);

                if(node.left!=null) queue.offer(node.left);
                if(node.right!=null) queue.offer(node.right);
                len--;
            }
            nodes.add(temp);
        }
    }
}
```





## 二叉树展开为链表*

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250215150921866.png" alt="image-20250215150921866" style="zoom:67%;" />	

反前序遍历：右左中，刚好能从6读到1。空间复杂读O(h)取决于树高，空间复杂度一般指的是额外的空间，这里递归遍历了，所以取决于树高

```java
class Solution {
    TreeNode lastNode;
    public void flatten(TreeNode root) {
        if(root==null) return;
        flatten(root.right);//右
        flatten(root.left);//左
        //中
        root.left=null;
        root.right=lastNode;
        //记录此时节点
        lastNode=root;
    }
}
```

暴力写法：直接存入List，然后修改root

```java
class Solution {
    public void flatten(TreeNode root) {
        if(root==null) return;
        List<TreeNode> nodes = new ArrayList<>();
        recordNode(root, nodes);
        if(nodes.size()==1) return;
        for(int i=0; i<nodes.size(); i++){
            root.left=null;
            root.right=nodes.get(i);
            root=root.right;
        }
    }

    public void recordNode(TreeNode cur, List<TreeNode> nodes){
        if(cur==null) return;
        nodes.add(cur);
        recordNode(cur.left, nodes);
        recordNode(cur.right, nodes);
    }
}
```

寻找前驱节点(空间复杂度O1)

思路：**每次找cur的左子节点的最右节点，然后将cur的右子树拼接到该右节点。再将该拼接完后的左子树拼接到cur的右节点上**

```java
class Solution {
    public void flatten(TreeNode root) {
        TreeNode cur = root;
        while(cur!=null){
            if(cur.left!=null){
                TreeNode next = cur.left;//用于后面拼接到cur右节点
                TreeNode preNode = next;//找左子节点的最右节点
                while(preNode.right!=null){
                    preNode=preNode.right;
                }
                preNode.right=cur.right;//把cur的右子树拼上去
                cur.left=null;//cur断左
                cur.right=next;//把拼接好的左子树放到右边去
            }
            cur=cur.right;//继续右，开始循环
        }
    }
}
```

看不懂的话可以看题解3的图

[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/356853/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/?envType=study-plan-v2&envId=top-100-liked)





## 路径综合Ⅲ

![image-20250215155401998](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250215155401998.png)

暴力：遍历所有点，然后以所有点为起点中序遍历顺便++，进行判断，符合则res++;

```java
class Solution {
    int res=0;
    List<TreeNode> nodes = new ArrayList<>();
    public int pathSum(TreeNode root, int targetSum) {
        TreeNode temp = root;
        getAllNodes(temp);
        for(TreeNode start : nodes){//每个点为起点进行判断
            tranversal(start, Long.valueOf(start.val), targetSum);
        }
        return res;
    }

    public void tranversal(TreeNode cur, Long sum, int targetSum){
        if(sum==targetSum){//符合就++
            res++;
        }
        if(cur.left!=null)
            tranversal(cur.left, sum+cur.left.val, targetSum);
        if(cur.right!=null)
            tranversal(cur.right, sum+cur.right.val, targetSum);
    }


    public void getAllNodes(TreeNode cur){//暴力获取所有点
        if(cur==null) return;
        nodes.add(cur);
        getAllNodes(cur.left);
        getAllNodes(cur.right);
    }
}
```





## 二叉树最近公共祖先*

<img src="D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250215160736416.png" alt="image-20250215160736416" style="zoom:67%;" />	

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //思路：只要找到一个节点就返回
        if(root==null) return null;
        if(p==root||q==root) return root;//找到其中之一
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        //核对结果，如果l和r都不为空，说明找到了
        if(right!=null && left!=null) return root;
        //如果只有一个找到，说明处于同一侧子树下，那么找到的该节点就是根
        if(left!=null) return left;
        if(right!=null) return right;
        return null;
    }
}
```



## 二叉树最大路径和*（和二叉树直径类似思路）

![image-20250215162137162](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250215162137162.png)

正常遍历，然后算当前节点作为根的路径，然后返回当前节点作为之路的路径

```java
class Solution {
    int maxn = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxn;
    }

    public int maxGain(TreeNode cur){
        if(cur==null) return 0;

        //只有大于0才取，不然只会让结果变小
        int leftGain = Math.max(maxGain(cur.left), 0);
        int rightGain = Math.max(maxGain(cur.right), 0);
        //以当前节点为根，来算路径长度
        int nowRes = cur.val+leftGain+rightGain;
        maxn=Math.max(maxn, nowRes);
        //返回当前节点作为支路时，因为不可能同时走两条路，就不符合路径一说了
        return cur.val+Math.max(leftGain, rightGain);
    }
}
```





## 子结构判断

![image-20250225221156282](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250225221156282.png)

思路：中序遍历A，遇到节点相同就check，check函数同时对两个节点进行判断和遍历就行

```java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(B==null) return false;
        if(A==null) return false;
        if(A.val==B.val && check(A, B)) return true;
        boolean l = isSubStructure(A.left, B);
        boolean r = isSubStructure(A.right, B);
        if(l==true || r==true) return true;//看上面那个if条件就可以知道，只要l或者r又一个true就成立
        return false;
    }

    public boolean check(TreeNode A, TreeNode B){
        if(A==null && B==null) return true;
        if(A==null) return false;//a==null说明A遍历完了，而B没有对齐，则是错的
        if(B==null) return true;
        if(A.val!=B.val) return false;
        boolean l = check(A.left, B.left);
        boolean r = check(A.right, B.right);
        if(l==true && r==true) return true;//因为是同时遍历，所以必须要同时成功
        else return false;  
    }
}
```





# 二分

## 搜索插入位置

![image-20250217225423776](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250217225423776.png)

新写法

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l=0; int r=nums.length-1;
        while(l<=r){
            int mid = l+(r-l)/2;
            if(nums[mid]<target) l=mid+1;
            else r=mid-1;
        }
        return l;
    }
}
```





## 搜索二维矩阵

![image-20250219144803581](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250219144803581.png)	

暴力做法:二分每一层

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n =matrix.length;
        int m =matrix[0].length;
        for(int i=0; i<n; i++){
            Boolean check = isExit(i, m, matrix, target);
            if(check==true) return true;
        }
        return false;
    }

    public boolean isExit(int cur, int m, int[][] matrix, int target){
        int l=0, r=m-1;
        while(l<=r){
            int mid = l+(r-l)/2;
            if(matrix[cur][mid]<target) l=mid+1;
            else r=mid-1;
        }
        if(l>=m) return false;
        return matrix[cur][l]==target?true:false;
    }
}
```

只扫描一次，通过映射二维坐标为一维, 行数用÷，列数用余 `matrix[mid/rowLen][mid%rowLen];`

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int colLen =matrix.length;
        int rowLen =matrix[0].length;

        int l=0, r=colLen*rowLen-1;
        while(l<=r){
            int mid = (r-l)/2+l;
            int x = matrix[mid/rowLen][mid%rowLen];
            if(x<target) l=mid+1;
            else if(x>target)r=mid-1;
            else return true;
        }
        return false;
    }
}
```



# 图论(包含部分dfs和bfs)

## 岛屿数量

![image-20250226220953924](D:\JAVA学习日志\typora\面试算法\算法灵感乍现.assets\image-20250226220953924.png)	

遇到一个1就进入函数同时res++，然后把所有1标成0

dfs(推荐)

```java
class Solution {
    int res=0;
    public int numIslands(char[][] grid) {
        if(grid==null || grid.length==0) return 0;

        int row = grid.length;
        int col = grid[0].length;

        for(int i=0; i<row; i++){
            for(int j=0; j<col; j++){
                if(grid[i][j]=='1'){
                    res++;
                    dfs(i, j, grid);
                }
            }
        }
        return res;
    }

    public void dfs(int i, int j, char[][] grid){
        if(grid[i][j]=='0') return;
        grid[i][j]='0';

        int row = grid.length;
        int col = grid[0].length;
        if(i-1>=0) dfs(i-1, j, grid);
        if(j+1<col) dfs(i, j+1, grid);
        if(i+1<row) dfs(i+1, j, grid);
        if(j-1>=0) dfs(i, j-1, grid);
    }
}
```

bfs(涉及一个细节)

```java
class Solution {
    int res=0;
    public int numIslands(char[][] grid) {
        if(grid==null || grid.length==0) return 0;

        int row = grid.length;
        int col = grid[0].length;

        for(int i=0; i<row; i++){
            for(int j=0; j<col; j++){
                if(grid[i][j]=='1'){
                    res++;
                    check(i, j, grid);
                }
            }
        }

        return res;
    }

    public void check(int i, int j, char[][] grid){
        int[] Dx = new int[]{-1, 0, 1, 0};
        int[] Dy = new int[]{0, 1, 0, -1};
        Queue<int[]> curque = new LinkedList<>();
        curque.add(new int[]{i, j});
        grid[i][j]='0';

        while(!curque.isEmpty()){
            int[] curIndex = curque.poll();
            int x = curIndex[0];
            int y = curIndex[1];
            // grid[x][y]='0';
            int row = grid.length;
            int col = grid[0].length;

            for(int h=0; h<4; h++){
                int curX = x+Dx[h];
                int curY = y+Dy[h];
                if(curX>=0 && curX<row && curY>=0 && curY<col && grid[curX][curY]=='1'){
                    //应该写在这里，如果写在上面那个位置，因为没有标记为0导致点会多走几次
                    grid[curX][curY]='0';
                    curque.add(new int[]{curX, curY});
                }
            }
        }
    }
}
```

